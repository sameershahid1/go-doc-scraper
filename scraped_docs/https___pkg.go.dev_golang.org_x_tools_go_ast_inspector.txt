inspector Details Repository Links DocumentationÂ¶ Source FilesÂ¶ Jump to Keyboard shortcuts OverviewÂ¶ IndexÂ¶ ConstantsÂ¶ VariablesÂ¶ FunctionsÂ¶ TypesÂ¶ funcAllÂ¶added inv0.26.0 typeInspectorÂ¶ funcNewÂ¶ func (Inspector)NodesÂ¶ func (Inspector)PreorderÂ¶ func (Inspector)PreorderSeqÂ¶added inv0.26.0 func (Inspector)WithStackÂ¶ Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go This package is not in the latest version of its module. The Go module system was introduced in Go 1.11 and is the official dependency management solution for Go. Redistributable licenses place minimal restrictions on how software can be used, modified, and redistributed. Modules with tagged versions give importers more predictable builds. When a project reaches major version v1 it is considered stable. Package inspector provides helper functions for traversal over the syntax trees of a package, including node filtering by type, and materialization of the traversal stack. During construction, the inspector does a complete traversal and builds a list of push/pop events and their node type. Subsequent method calls that request a traversal scan this list, rather than walk the AST, and perform type filtering using efficient bit sets. Experiments suggest the inspector's traversals are about 2.5x faster than ast.Inspect, but it may take around 5 traversals for this benefit to amortize the inspector's construction cost. If efficiency is the primary concern, do not use Inspector for one-off traversals. This section is empty. This section is empty. All[N] returns an iterator over all the nodes of type N. N must be a pointer-to-struct type that implements ast.Node. Example: An Inspector provides methods for inspecting (traversing) the syntax trees of a package. New returns an Inspector for the specified syntax trees. Nodes visits the nodes of the files supplied to New in depth-first order. It calls f(n, true) for each node n before it visits n's children. If f returns true, Nodes invokes f recursively for each of the non-nil children of the node, followed by a call of f(n, false). The complete traversal sequence is determined by ast.Inspect. The types argument, if non-empty, enables type-based filtering of events. The function f if is called only for nodes whose type matches an element of the types slice. Preorder visits all the nodes of the files supplied to New in depth-first order. It calls f(n) for each node n before it visits n's children. The complete traversal sequence is determined by ast.Inspect. The types argument, if non-empty, enables type-based filtering of events. The function f is called only for nodes whose type matches an element of the types slice. PreorderSeq returns an iterator that visits all the nodes of the files supplied to New in depth-first order. It visits each node n before n's children. The complete traversal sequence is determined by ast.Inspect. The types argument, if non-empty, enables type-based filtering of events: only nodes whose type matches an element of the types slice are included in the sequence. WithStack visits nodes in a similar manner to Nodes, but it supplies each call to f an additional argument, the current traversal stack. The stack's first element is the outermost node, an ast.File; its last is the innermost, n. Theme Toggle Shortcuts Modal Why GoCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurity PolicyHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go Security PolicyHow Go can help keep you secure by default Learn DocsEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release Packages CommunityRecorded TalksVideos from prior eventsMeetupsMeet other local Go developersConferencesLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsMeet other local Go developers ConferencesLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GoWhy GoCase StudiesUse CasesSecurity Policy Case Studies Use Cases Security Policy Learn DocsDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunityCommunityRecorded TalksMeetupsConferencesGo blogGo projectGet connected Recorded Talks Meetups Conferences Go blog Go project Get connected Discover Packages golang.org/x/tools go ast inspector Validgo.modfileThe Go module system was introduced in Go 1.11 and is the official dependency management solution for Go. Redistributable licenseRedistributable licenses place minimal restrictions on how software can be used, modified, and redistributed. Tagged versionModules with tagged versions give importers more predictable builds. Stable versionWhen a project reaches major version v1 it is considered stable. Learn more about best practices Report a Vulnerability DocumentationOverviewIndexConstantsVariablesFunctionsAll(in)Typestype InspectorNew(files)(in) Nodes(types, f)(in) Preorder(types, f)(in) PreorderSeq(types)(in) WithStack(types, f) Overview Index Constants Variables FunctionsAll(in) All(in) Typestype InspectorNew(files)(in) Nodes(types, f)(in) Preorder(types, f)(in) PreorderSeq(types)(in) WithStack(types, f) type InspectorNew(files)(in) Nodes(types, f)(in) Preorder(types, f)(in) PreorderSeq(types)(in) WithStack(types, f) New(files) (in) Nodes(types, f) (in) Preorder(types, f) (in) PreorderSeq(types) (in) WithStack(types, f) Source Files func All[N interface{ ... }, S any](in Inspector) iter.Seq[N] type Inspector func New(files []ast.File) Inspector func New(files []ast.File) Inspector func (in Inspector) Nodes(types []ast.Node, f func(n ast.Node, push bool) (proceed bool))func (in Inspector) Preorder(types []ast.Node, f func(ast.Node))func (in Inspector) PreorderSeq(types ...ast.Node) iter.Seq[ast.Node]func (in Inspector) WithStack(types []ast.Node, ...) func (in Inspector) Nodes(types []ast.Node, f func(n ast.Node, push bool) (proceed bool)) func (in Inspector) Preorder(types []ast.Node, f func(ast.Node)) func (in Inspector) PreorderSeq(types ...ast.Node) iter.Seq[ast.Node] func (in Inspector) WithStack(types []ast.Node, ...) inspector.go iter.go typeof.go walk.go Copyright Terms of Service Privacy Policy Report an Issue Theme Toggle Shortcuts Modal go func All[N interface { S ast.Node }, S any](in Inspector) iter.Seq[N]  go for call := range All[ast.CallExpr](in) { ... }  go type Inspector struct { // contains filtered or unexported fields }  go func New(files []ast.File) Inspector  go func (in Inspector) Nodes(types []ast.Node, f func(n ast.Node, push bool) (proceed bool))  go func (in Inspector) Preorder(types []ast.Node, f func(ast.Node))  go func (in Inspector) PreorderSeq(types ...ast.Node) iter.Seq[ast.Node]  go func (in Inspector) WithStack(types []ast.Node, f func(n ast.Node, push bool, stack []ast.Node) (proceed bool))  +------+-----------------+ | ? | : This menu | +------+-----------------+ | / | : Search site | +------+-----------------+ | forF | : Jump to | +------+-----------------+ | yorY | : Canonical URL | +------+-----------------+ ðŸ’¡ Why Go Why Go Case Studies Use Cases Security Policy Learn Docs Docs Effective Go Go User Manual Standard library Release Notes Packages Community Community Recorded Talks Meetups Conferences Go blog Go project Get connected ðŸ’¡ Details Valid go.mod file The Go module system was introduced in Go 1.11 and is the official dependency management solution for Go. Redistributable license Redistributable licenses place minimal restrictions on how software can be used, modified, and redistributed. Tagged version Modules with tagged versions give importers more predictable builds. Stable version When a project reaches major version v1 it is considered stable. Learn more about best practices Repository cs.opensource.google/go/x/tools Links Report a Vulnerability