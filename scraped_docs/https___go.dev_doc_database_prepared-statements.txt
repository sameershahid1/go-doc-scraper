Using prepared statements What is a prepared statement? How you use prepared statements Prepared statement behavior Functions for creating a prepared statement Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go You can define a prepared statement for repeated use. This can help your code run a bit faster by avoiding the overhead of re-creating the statement each time your code performs the database operation. Note:Parameter placeholders in prepared statements vary depending on the DBMS and driver youâ€™re using. For example, thepq driverfor Postgres requires a placeholder like$1instead of?. A prepared statement is SQL that is parsed and saved by the DBMS, typically containing placeholders but with no actual parameter values. Later, the statement can be executed with a set of parameter values. When you expect to execute the same SQL repeatedly, you can use ansql.Stmtto prepare the SQL statement in advance, then execute it as needed. The following example creates a prepared statement that selects a specific album from the database.DB.Preparereturns ansql.Stmtrepresenting a prepared statement for a given SQL text. You can pass the parameters for the SQL statement toStmt.Exec,Stmt.QueryRow, orStmt.Queryto run the statement. A preparedsql.Stmtprovides the usualExec,QueryRow, andQuerymethods for invoking the statement. For more on using these methods, seeQuerying for dataandExecuting SQL statements that donâ€™t return data. However, because ansql.Stmtalready represents a preset SQL statement, itsExec,QueryRow, andQuerymethods take only the SQL parameter values corresponding to placeholders, omitting the SQL text. You can define a newsql.Stmtin different ways, depending on how you will use it. Be sure thatstmt.Closeis called when your code is finished with a statement. This will release any database resources (such as underlying connections) that may be associated with it. For statements that are only local variables in a function, itâ€™s enough todefer stmt.Close(). Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected DB.PrepareandDB.PrepareContextcreate a prepared statement that can be executed in isolation, by itself outside a transaction, just likeDB.ExecandDB.Queryare. Tx.Prepare,Tx.PrepareContext,Tx.Stmt, andTx.StmtContextcreate a prepared statement for use in a specific transaction.PrepareandPrepareContextuse SQL text to define the statement.StmtandStmtContextuse the result ofDB.PrepareorDB.PrepareContext. That is, they convert a not-for-transactionssql.Stmtinto a for-this-transactionsql.Stmt. Conn.PrepareContextcreates a prepared statement from ansql.Conn, which represents a reserved connection. Copyright Terms of Service Privacy Policy Report an Issue go // AlbumByID retrieves the specified album. func AlbumByID(id int) (Album, error) { // Define a prepared statement. You'd typically define the statement // elsewhere and save it for use in functions such as this one. stmt, err := db.Prepare("SELECT  FROM album WHERE id = ?") if err != nil { log.Fatal(err) } var album Album // Execute the prepared statement, passing in an id value for the // parameter whose placeholder is ? err := stmt.QueryRow(id).Scan(&album.ID, &album.Title, &album.Artist, &album.Price, &album.Quantity) if err != nil { if err == sql.ErrNoRows { // Handle the case of no rows returned. } return album, err } return album, nil }  $1 ? sql.Stmt DB.Prepare Stmt.Exec Stmt.QueryRow Stmt.Query // AlbumByID retrieves the specified album. func AlbumByID(id int) (Album, error) { // Define a prepared statement. You'd typically define the statement // elsewhere and save it for use in functions such as this one. stmt, err := db.Prepare("SELECT  FROM album WHERE id = ?") if err != nil { log.Fatal(err) } var album Album // Execute the prepared statement, passing in an id value for the // parameter whose placeholder is ? err := stmt.QueryRow(id).Scan(&album.ID, &album.Title, &album.Artist, &album.Price, &album.Quantity) if err != nil { if err == sql.ErrNoRows { // Handle the case of no rows returned. } return album, err } return album, nil } Exec QueryRow Query DB.PrepareContext DB.Exec DB.Query Tx.Prepare Tx.PrepareContext Tx.Stmt Tx.StmtContext Prepare PrepareContext Stmt StmtContext Conn.PrepareContext sql.Conn stmt.Close defer stmt.Close() +--------------------------------------------------+---------------------------------------------------------------------------+ | Function | Description | +--------------------------------------------------+---------------------------------------------------------------------------+ | DB.PrepareDB.PrepareContext | Prepare a statement for execution in | | | isolation or that will be converted to an in-transaction' | | | prepared statement using Tx.Stmt. | +--------------------------------------------------+---------------------------------------------------------------------------+ | Tx.PrepareTx.PrepareContextTx.StmtTx.StmtContext | Prepare a statement for use in a specific | | | transaction. For more, seeExecuting | | | transactions. | +--------------------------------------------------+---------------------------------------------------------------------------+ | Conn.PrepareContext | For use with reserved connections. | | | For more, seeManaging connections. | +--------------------------------------------------+---------------------------------------------------------------------------+ ðŸ’¡ Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected