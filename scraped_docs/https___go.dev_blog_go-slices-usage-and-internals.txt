The Go Blog Go Slices: usage and internals Introduction Arrays Slices Slice internals Growing slices (the copy and append functions) A possible “gotcha” Further Reading Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Andrew Gerrand5 January 2011 Go’s slice type provides a convenient and efficient means of working with sequences of typed data. Slices are analogous to arrays in other languages, but have some unusual properties. This article will look at what slices are and how they are used. The slice type is an abstraction built on top of Go’s array type, and so to understand slices we must first understand arrays. An array type definition specifies a length and an element type. For example, the type[4]intrepresents an array of four integers. An array’s size is fixed; its length is part of its type ([4]intand[5]intare distinct, incompatible types). Arrays can be indexed in the usual way, so the expressions[n]accesses the nth element, starting from zero. Arrays do not need to be initialized explicitly; the zero value of an array is a ready-to-use array whose elements are themselves zeroed: The in-memory representation of[4]intis just four integer values laid out sequentially: Go’s arrays are values. An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C). This means that when you assign or pass around an array value you will make a copy of its contents. (To avoid the copy you could pass apointerto the array, but then that’s a pointer to an array, not an array.) One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value. An array literal can be specified like so: Or, you can have the compiler count the array elements for you: In both cases, the type ofbis[2]string. Arrays have their place, but they’re a bit inflexible, so you don’t see them too often in Go code. Slices, though, are everywhere. They build on arrays to provide great power and convenience. The type specification for a slice is[]T, whereTis the type of the elements of the slice. Unlike an array type, a slice type has no specified length. A slice literal is declared just like an array literal, except you leave out the element count: A slice can be created with the built-in function calledmake, which has the signature, where T stands for the element type of the slice to be created. Themakefunction takes a type, a length, and an optional capacity. When called,makeallocates an array and returns a slice that refers to that array. When the capacity argument is omitted, it defaults to the specified length. Here’s a more succinct version of the same code: The length and capacity of a slice can be inspected using the built-inlenandcapfunctions. The next two sections discuss the relationship between length and capacity. The zero value of a slice isnil. Thelenandcapfunctions will both return 0 for a nil slice. A slice can also be formed by “slicing” an existing slice or array. Slicing is done by specifying a half-open range with two indices separated by a colon. For example, the expressionb[1:4]creates a slice including elements 1 through 3 ofb(the indices of the resulting slice will be 0 through 2). The start and end indices of a slice expression are optional; they default to zero and the slice’s length respectively: This is also the syntax to create a slice given an array: A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment). Our variables, created earlier bymake([]byte, 5), is structured like this: The length is the number of elements referred to by the slice. The capacity is the number of elements in the underlying array (beginning at the element referred to by the slice pointer). The distinction between length and capacity will be made clear as we walk through the next few examples. As we slices, observe the changes in the slice data structure and their relation to the underlying array: Slicing does not copy the slice’s data. It creates a new slice value that points to the original array. This makes slice operations as efficient as manipulating array indices. Therefore, modifying theelements(not the slice itself) of a re-slice modifies the elements of the original slice: Earlier we slicedsto a length shorter than its capacity. We can grow s to its capacity by slicing it again: A slice cannot be grown beyond its capacity. Attempting to do so will cause a runtime panic, just as when indexing outside the bounds of a slice or array. Similarly, slices cannot be re-sliced below zero to access earlier elements in the array. To increase the capacity of a slice one must create a new, larger slice and copy the contents of the original slice into it. This technique is how dynamic array implementations from other languages work behind the scenes. The next example doubles the capacity ofsby making a new slice,t, copying the contents ofsintot, and then assigning the slice valuettos: The looping piece of this common operation is made easier by the built-in copy function. As the name suggests, copy copies data from a source slice to a destination slice. It returns the number of elements copied. Thecopyfunction supports copying between slices of different lengths (it will copy only up to the smaller number of elements). In addition,copycan handle source and destination slices that share the same underlying array, handling overlapping slices correctly. Usingcopy, we can simplify the code snippet above: A common operation is to append data to the end of a slice. This function appends byte elements to a slice of bytes, growing the slice if necessary, and returns the updated slice value: One could useAppendBytelike this: Functions likeAppendByteare useful because they offer complete control over the way the slice is grown. Depending on the characteristics of the program, it may be desirable to allocate in smaller or larger chunks, or to put a ceiling on the size of a reallocation. But most programs don’t need complete control, so Go provides a built-inappendfunction that’s good for most purposes; it has the signature Theappendfunction appends the elementsxto the end of the slices, and grows the slice if a greater capacity is needed. To append one slice to another, use...to expand the second argument to a list of arguments. Since the zero value of a slice (nil) acts like a zero-length slice, you can declare a slice variable and then append to it in a loop: As mentioned earlier, re-slicing a slice doesn’t make a copy of the underlying array. The full array will be kept in memory until it is no longer referenced. Occasionally this can cause the program to hold all the data in memory when only a small piece of it is needed. For example, thisFindDigitsfunction loads a file into memory and searches it for the first group of consecutive numeric digits, returning them as a new slice. This code behaves as advertised, but the returned[]bytepoints into an array containing the entire file. Since the slice references the original array, as long as the slice is kept around the garbage collector can’t release the array; the few useful bytes of the file keep the entire contents in memory. To fix this problem one can copy the interesting data to a new slice before returning it: A more concise version of this function could be constructed by usingappend. This is left as an exercise for the reader. Effective Gocontains an in-depth treatment ofslicesandarrays, and the Golanguage specificationdefinesslicesand theirassociatedhelperfunctions. Next article:JSON and GoPrevious article:Go: one year ago todayBlog Index Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Copyright Terms of Service Privacy Policy Report an Issue go var a [4]int a[0] = 1 i := a[0] // i == 1  go // a[2] == 0, the zero value of the int type  go b := [2]string{"Penn", "Teller"}  go b := [...]string{"Penn", "Teller"}  go letters := []string{"a", "b", "c", "d"}  go func make([]T, len, cap) []T  go var s []byte s = make([]byte, 5, 5) // s == []byte{0, 0, 0, 0, 0}  go s := make([]byte, 5)  go len(s) == 5 cap(s) == 5  go b := []byte{'g', 'o', 'l', 'a', 'n', 'g'} // b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b  go // b[:2] == []byte{'g', 'o'} // b[2:] == []byte{'l', 'a', 'n', 'g'} // b[:] == b  go x := [3]string{"Лайка", "Белка", "Стрелка"} s := x[:] // a slice referencing the storage of x  go s = s[2:4]  go d := []byte{'r', 'o', 'a', 'd'} e := d[2:] // e == []byte{'a', 'd'} e[1] = 'm' // e == []byte{'a', 'm'} // d == []byte{'r', 'o', 'a', 'm'}  go s = s[:cap(s)]  go t := make([]byte, len(s), (cap(s)+1)2) // +1 in case cap(s) == 0 for i := range s { t[i] = s[i] } s = t  go func copy(dst, src []T) int  go t := make([]byte, len(s), (cap(s)+1)2) copy(t, s) s = t  go func AppendByte(slice []byte, data ...byte) []byte { m := len(slice) n := m + len(data) if n > cap(slice) { // if necessary, reallocate // allocate double what's needed, for future growth. newSlice := make([]byte, (n+1)2) copy(newSlice, slice) slice = newSlice } slice = slice[0:n] copy(slice[m:n], data) return slice }  go p := []byte{2, 3, 5} p = AppendByte(p, 7, 11, 13) // p == []byte{2, 3, 5, 7, 11, 13}  go func append(s []T, x ...T) []T  go a := make([]int, 1) // a == []int{0} a = append(a, 1, 2, 3) // a == []int{0, 1, 2, 3}  go a := []string{"John", "Paul"} b := []string{"George", "Ringo", "Pete"} a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])" // a == []string{"John", "Paul", "George", "Ringo", "Pete"}  go // Filter returns a new slice holding only // the elements of s that satisfy fn() func Filter(s []int, fn func(int) bool) []int { var p []int // == nil for , v := range s { if fn(v) { p = append(p, v) } } return p }  go var digitRegexp = regexp.MustCompile("[0-9]+") func FindDigits(filename string) []byte { b,  := ioutil.ReadFile(filename) return digitRegexp.Find(b) }  go func CopyDigits(filename string) []byte { b,  := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c }  [4]int [5]int s[n] var a [4]int a[0] = 1 i := a[0] // i == 1 // a[2] == 0, the zero value of the int type b := [2]string{"Penn", "Teller"} b := [...]string{"Penn", "Teller"} b [2]string []T T letters := []string{"a", "b", "c", "d"} make func make([]T, len, cap) []T var s []byte s = make([]byte, 5, 5) // s == []byte{0, 0, 0, 0, 0} s := make([]byte, 5) len cap len(s) == 5 cap(s) == 5 nil b[1:4] b := []byte{'g', 'o', 'l', 'a', 'n', 'g'} // b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b // b[:2] == []byte{'g', 'o'} // b[2:] == []byte{'l', 'a', 'n', 'g'} // b[:] == b x := [3]string{"Лайка", "Белка", "Стрелка"} s := x[:] // a slice referencing the storage of x s make([]byte, 5) s = s[2:4] d := []byte{'r', 'o', 'a', 'd'} e := d[2:] // e == []byte{'a', 'd'} e[1] = 'm' // e == []byte{'a', 'm'} // d == []byte{'r', 'o', 'a', 'm'} s = s[:cap(s)] t t := make([]byte, len(s), (cap(s)+1)2) // +1 in case cap(s) == 0 for i := range s { t[i] = s[i] } s = t func copy(dst, src []T) int copy t := make([]byte, len(s), (cap(s)+1)2) copy(t, s) s = t func AppendByte(slice []byte, data ...byte) []byte { m := len(slice) n := m + len(data) if n > cap(slice) { // if necessary, reallocate // allocate double what's needed, for future growth. newSlice := make([]byte, (n+1)2) copy(newSlice, slice) slice = newSlice } slice = slice[0:n] copy(slice[m:n], data) return slice } AppendByte p := []byte{2, 3, 5} p = AppendByte(p, 7, 11, 13) // p == []byte{2, 3, 5, 7, 11, 13} append func append(s []T, x ...T) []T x a := make([]int, 1) // a == []int{0} a = append(a, 1, 2, 3) // a == []int{0, 1, 2, 3} ... a := []string{"John", "Paul"} b := []string{"George", "Ringo", "Pete"} a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])" // a == []string{"John", "Paul", "George", "Ringo", "Pete"} // Filter returns a new slice holding only // the elements of s that satisfy fn() func Filter(s []int, fn func(int) bool) []int { var p []int // == nil for , v := range s { if fn(v) { p = append(p, v) } } return p } FindDigits var digitRegexp = regexp.MustCompile("[0-9]+") func FindDigits(filename string) []byte { b,  := ioutil.ReadFile(filename) return digitRegexp.Find(b) } []byte func CopyDigits(filename string) []byte { b,  := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c } 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected