A Quick Guide to Go's Assembler A Quick Guide to Go's Assembler Architecture-specific details Constants Symbols Directives Special instructions Interacting with Go types and constants Runtime Coordination 32-bit Intel 386 64-bit Intel 386 (a.k.a. amd64) ARM ARM64 PPC64 IBM z/Architecture, a.k.a. s390x MIPS, MIPS64 Unsupported opcodes Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go This document is a quick outline of the unusual form of assembly language used by thegcGo compiler. The document is not comprehensive. The assembler is based on the input style of the Plan 9 assemblers, which is documented in detailelsewhere. If you plan to write assembly language, you should read that document although much of it is Plan 9-specific. The current document provides a summary of the syntax and the differences with what is explained in that document, and describes the peculiarities that apply when writing assembly code to interact with Go. The most important thing to know about Go's assembler is that it is not a direct representation of the underlying machine. Some of the details map precisely to the machine, but some do not. This is because the compiler suite (seethis description) needs no assembler pass in the usual pipeline. Instead, the compiler operates on a kind of semi-abstract instruction set, and instruction selection occurs partly after code generation. The assembler works on the semi-abstract form, so when you see an instruction likeMOVwhat the toolchain actually generates for that operation might not be a move instruction at all, perhaps a clear or load. Or it might correspond exactly to the machine instruction with that name. In general, machine-specific operations tend to appear as themselves, while more general concepts like memory move and subroutine call and return are more abstract. The details vary with architecture, and we apologize for the imprecision; the situation is not well-defined. The assembler program is a way to parse a description of that semi-abstract instruction set and turn it into instructions to be input to the linker. If you want to see what the instructions look like in assembly for a given architecture, say amd64, there are many examples in the sources of the standard library, in packages such asruntimeandmath/big. You can also examine what the compiler emits as assembly code (the actual output may differ from what you see here): TheFUNCDATAandPCDATAdirectives contain information for use by the garbage collector; they are introduced by the compiler. To see what gets put in the binary after linking, usego tool objdump: Although the assembler takes its guidance from the Plan 9 assemblers, it is a distinct program, so there are some differences. One is in constant evaluation. Constant expressions in the assembler are parsed using Go's operator precedence, not the C-like precedence of the original. Thus3&1<<2is 4, not 0—it parses as(3&1)<<2not3&(1<<2). Also, constants are always evaluated as 64-bit unsigned integers. Thus-2is not the integer value minus two, but the unsigned 64-bit integer with the same bit pattern. The distinction rarely matters but to avoid ambiguity, division or right shift where the right operand's high bit is set is rejected. Some symbols, such asR1orLR, are predefined and refer to registers. The exact set depends on the architecture. There are four predeclared symbols that refer to pseudo-registers. These are not real registers, but rather virtual registers maintained by the toolchain, such as a frame pointer. The set of pseudo-registers is the same for all architectures: All user-defined symbols are written as offsets to the pseudo-registersFP(arguments and locals) andSB(globals). TheSBpseudo-register can be thought of as the origin of memory, so the symbolfoo(SB)is the namefooas an address in memory. This form is used to name global functions and data. Adding<>to the name, as infoo<>(SB), makes the name visible only in the current source file, like a top-levelstaticdeclaration in a C file. Adding an offset to the name refers to that offset from the symbol's address, sofoo+4(SB)is four bytes past the start offoo. TheFPpseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus0(FP)is the first argument to the function,8(FP)is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as infirstarg+0(FP)andsecondarg+8(FP). (The meaning of the offset—offset from the frame pointer—distinct from its use withSB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain0(FP)and8(FP). The actual name is semantically irrelevant but should be used to document the argument's name. It is worth stressing thatFPis always a pseudo-register, not a hardware register, even on architectures with a hardware frame pointer. For assembly functions with Go prototypes,govetwill check that the argument names and offsets match. On 32-bit systems, the low and high 32 bits of a 64-bit value are distinguished by adding aloorhisuffix to the name, as inarglo+0(FP)orarghi+4(FP). If a Go prototype does not name its result, the expected assembly name isret. TheSPpseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls. It points to the highest address within the local stack frame, so references should use negative offsets in the range [−framesize, 0):x-8(SP),y-4(SP), and so on. On architectures with a hardware register namedSP, the name prefix distinguishes references to the virtual stack pointer from references to the architecturalSPregister. That is,x-8(SP)and-8(SP)are different memory locations: the first refers to the virtual stack pointer pseudo-register, while the second refers to the hardware'sSPregister. On machines whereSPandPCare traditionally aliases for a physical, numbered register, in the Go assembler the namesSPandPCare still treated specially; for instance, references toSPrequire a symbol, much likeFP. To access the actual hardware register use the trueRname. For example, on the ARM architecture the hardwareSPandPCare accessible asR13andR15. Branches and direct jumps are always written as offsets to the PC, or as jumps to labels: Each label is visible only within the function in which it is defined. It is therefore permitted for multiple functions in a file to define and use the same label names. Direct jumps and call instructions can target text symbols, such asname(SB), but not offsets from symbols, such asname+4(SB). Instructions, registers, and assembler directives are always in UPPER CASE to remind you that assembly programming is a fraught endeavor. (Exception: thegregister renaming on ARM.) In Go object files and binaries, the full name of a symbol is the package path followed by a period and the symbol name:fmt.Printformath/rand.Int. Because the assembler's parser treats period and slash as punctuation, those strings cannot be used directly as identifier names. Instead, the assembler allows the middle dot character U+00B7 and the division slash U+2215 in identifiers and rewrites them to plain period and slash. Within an assembler source file, the symbols above are written asfmt·Printfandmath∕rand·Int. The assembly listings generated by the compilers when using the-Sflag show the period and slash directly instead of the Unicode replacements required by the assemblers. Most hand-written assembly files do not include the full package path in symbol names, because the linker inserts the package path of the current object file at the beginning of any name starting with a period: in an assembly source file within the math/rand package implementation, the package's Int function can be referred to as·Int. This convention avoids the need to hard-code a package's import path in its own source code, making it easier to move the code from one location to another. The assembler uses various directives to bind text and data to symbol names. For example, here is a simple complete function definition. TheTEXTdirective declares the symbolruntime·profileloopand the instructions that follow form the body of the function. The last instruction in aTEXTblock must be some sort of jump, usually aRET(pseudo-)instruction. (If it's not, the linker will append a jump-to-itself instruction; there is no fallthrough inTEXTs.) After the symbol, the arguments are flags (see below) and the frame size, a constant (but see below): In the general case, the frame size is followed by an argument size, separated by a minus sign. (It's not a subtraction, just idiosyncratic syntax.) The frame size$24-8states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller's frame. IfNOSPLITis not specified for theTEXT, the argument size must be provided. For assembly functions with Go prototypes,govetwill check that the argument size is correct. Note that the symbol name uses a middle dot to separate the components and is specified as an offset from the static base pseudo-registerSB. This function would be called from Go source for packageruntimeusing the simple nameprofileloop. Global data symbols are defined by a sequence of initializingDATAdirectives followed by aGLOBLdirective. EachDATAdirective initializes a section of the corresponding memory. The memory not explicitly initialized is zeroed. The general form of theDATAdirective isDATA symbol+offset(SB)/width, valuewhich initializes the symbol memory at the given offset and width with the given value. TheDATAdirectives for a given symbol must be written with increasing offsets.TheGLOBLdirective declares a symbol to be global. The arguments are optional flags and the size of the data being declared as a global, which will have initial value all zeros unless aDATAdirective has initialized it. TheGLOBLdirective must follow any correspondingDATAdirectives.For example,DATA divtab<>+0x00(SB)/4, $0xf4f8fcff DATA divtab<>+0x04(SB)/4, $0xe6eaedf0 ... DATA divtab<>+0x3c(SB)/4, $0x81828384 GLOBL divtab<>(SB), RODATA, $64 GLOBL runtime·tlsoffset(SB), NOPTR, $4declares and initializesdivtab<>, a read-only 64-byte table of 4-byte integer values, and declaresruntime·tlsoffset, a 4-byte, implicitly zeroed variable that contains no pointers.There may be one or two arguments to the directives. If there are two, the first is a bit mask of flags, which can be written as numeric expressions, added or or-ed together, or can be set symbolically for easier absorption by a human. Their values, defined in the standard#includefiletextflag.h, are:NOPROF= 1(ForTEXTitems.) Don't profile the marked function. This flag is deprecated.DUPOK= 2It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use.NOSPLIT= 4(ForTEXTitems.) Don't insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space remaining in the current stack segment. Used to protect routines such as the stack splitting code itself.RODATA= 8(ForDATAandGLOBLitems.) Put this data in a read-only section.NOPTR= 16(ForDATAandGLOBLitems.) This data contains no pointers and therefore does not need to be scanned by the garbage collector.WRAPPER= 32(ForTEXTitems.) This is a wrapper function and should not count as disablingrecover.NEEDCTXT= 64(ForTEXTitems.) This function is a closure so it uses its incoming context register.LOCAL= 128This symbol is local to the dynamic shared object.TLSBSS= 256(ForDATAandGLOBLitems.) Put this data in thread local storage.NOFRAME= 512(ForTEXTitems.) Do not insert instructions to allocate a stack frame and save/restore the return address, even if this is not a leaf function. Only valid on functions that declare a frame size of 0.TOPFRAME= 2048(ForTEXTitems.) Function is the outermost frame of the call stack. Traceback should stop at this function.Special instructionsThePCALIGNpseudo-instruction is used to indicate that the next instruction should be aligned to a specified boundary by padding with no-op instructions.It is currently supported on arm64, amd64, ppc64, loong64 and riscv64. For example, the start of theMOVDinstruction below is aligned to 32 bytes:PCALIGN $32 MOVD $2, R0Interacting with Go types and constantsIf a package has any .s files, thengo buildwill direct the compiler to emit a special header calledgoasm.h, which the .s files can then#include. The file contains symbolic#defineconstants for the offsets of Go struct fields, the sizes of Go struct types, and most Goconstdeclarations defined in the current package. Go assembly should avoid making assumptions about the layout of Go types and instead use these constants. This improves the readability of assembly code, and keeps it robust to changes in data layout either in the Go type definitions or in the layout rules used by the Go compiler.Constants are of the formconstname. For example, given the Go declarationconst bufSize = 1024, assembly code can refer to the value of this constant asconstbufSize.Field offsets are of the formtypefield. Struct sizes are of the formtypesize. For example, consider the following Go definition:type reader struct { buf [bufSize]byte r int }Assembly can refer to the size of this struct asreadersizeand the offsets of the two fields asreaderbufandreaderr. Hence, if registerR1contains a pointer to areader, assembly can reference therfield asreaderr(R1).If any of these#definenames are ambiguous (for example, a struct with asizefield),#include "goasm.h"will fail with a "redefinition of macro" error.Runtime CoordinationFor garbage collection to run correctly, the runtime must know the location of pointers in all global data and in most stack frames. The Go compiler emits this information when compiling Go source files, but assembly programs must define it explicitly.A data symbol marked with theNOPTRflag (see above) is treated as containing no pointers to runtime-allocated data. A data symbol with theRODATAflag is allocated in read-only memory and is therefore treated as implicitly markedNOPTR. A data symbol with a total size smaller than a pointer is also treated as implicitly markedNOPTR. It is not possible to define a symbol containing pointers in an assembly source file; such a symbol must be defined in a Go source file instead. Assembly source can still refer to the symbol by name even withoutDATAandGLOBLdirectives. A good general rule of thumb is to define all non-RODATAsymbols in Go instead of in assembly.Each function also needs annotations giving the location of live pointers in its arguments, results, and local stack frame. For an assembly function with no pointer results and either no local stack frame or no function calls, the only requirement is to define a Go prototype for the function in a Go source file in the same package. The name of the assembly function must not contain the package name component (for example, functionSyscallin packagesyscallshould use the name·Syscallinstead of the equivalent namesyscall·Syscallin itsTEXTdirective). For more complex situations, explicit annotation is needed. These annotations use pseudo-instructions defined in the standard#includefilefuncdata.h.If a function has no arguments and no results, the pointer information can be omitted. This is indicated by an argument size annotation of$n-0on theTEXTinstruction. Otherwise, pointer information must be provided by a Go prototype for the function in a Go source file, even for assembly functions not called directly from Go. (The prototype will also letgovetcheck the argument references.) At the start of the function, the arguments are assumed to be initialized but the results are assumed uninitialized. If the results will hold live pointers during a call instruction, the function should start by zeroing the results and then executing the pseudo-instructionGORESULTSINITIALIZED. This instruction records that the results are now initialized and should be scanned during stack movement and garbage collection. It is typically easier to arrange that assembly functions do not return pointers or do not contain call instructions; no assembly functions in the standard library useGORESULTSINITIALIZED.If a function has no local stack frame, the pointer information can be omitted. This is indicated by a local frame size annotation of$0-non theTEXTinstruction. The pointer information can also be omitted if the function contains no call instructions. Otherwise, the local stack frame must not contain pointers, and the assembly must confirm this fact by executing the pseudo-instructionNOLOCALPOINTERS. Because stack resizing is implemented by moving the stack, the stack pointer may change during any function call: even pointers to stack data must not be kept in local variables.Assembly functions should always be given Go prototypes, both to provide pointer information for the arguments and results and to letgovetcheck that the offsets being used to access them are correct.Architecture-specific detailsIt is impractical to list all the instructions and other details for each machine. To see what instructions are defined for a given machine, say ARM, look in the source for theobjsupport library for that architecture, located in the directorysrc/cmd/internal/obj/arm. In that directory is a filea.out.go; it contains a long list of constants starting withA, like this:const ( AAND = obj.ABaseARM + obj.AARCHSPECIFIC + iota AEOR ASUB ARSB AADD ...This is the list of instructions and their spellings as known to the assembler and linker for that architecture. Each instruction begins with an initial capitalAin this list, soAANDrepresents the bitwise and instruction,AND(without the leadingA), and is written in assembly source asAND. The enumeration is mostly in alphabetical order. (The architecture-independentAXXX, defined in thecmd/internal/objpackage, represents an invalid instruction). The sequence of theAnames has nothing to do with the actual encoding of the machine instructions. Thecmd/internal/objpackage takes care of that detail.The instructions for both the 386 and AMD64 architectures are listed incmd/internal/obj/x86/a.out.go.The architectures share syntax for common addressing modes such as(R1)(register indirect),4(R1)(register indirect with offset), and$foo(SB)(absolute address). The assembler also supports some (not necessarily all) addressing modes specific to each architecture. The sections below list these.One detail evident in the examples from the previous sections is that data in the instructions flows from left to right:MOVQ$0,CXclearsCX. This rule applies even on architectures where the conventional notation uses the opposite direction.Here follow some descriptions of key Go-specific details for the supported architectures.32-bit Intel 386The runtime pointer to thegstructure is maintained through the value of an otherwise unused (as far as Go is concerned) register in the MMU. In the runtime package, assembly code can includegotls.h, which defines an OS- and architecture-dependent macrogettlsfor accessing this register. Thegettlsmacro takes one argument, which is the register to load thegpointer into.For example, the sequence to loadgandmusingCXlooks like this:#include "gotls.h" #include "goasm.h" ... gettls(CX) MOVL g(CX), AX // Move g into AX. MOVL gm(AX), BX // Move g.m into BX.Thegettlsmacro is also defined onamd64.Addressing modes:(DI)(BX2): The location at addressDIplusBX2.64(DI)(BX2): The location at addressDIplusBX2plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.When using the compiler and assembler's-dynlinkor-sharedmodes, any load or store of a fixed memory location such as a global variable must be assumed to overwriteCX. Therefore, to be safe for use with these modes, assembly sources should typically avoid CX except between memory references.64-bit Intel 386 (a.k.a. amd64)The two architectures behave largely the same at the assembler level. Assembly code to access themandgpointers on the 64-bit version is the same as on the 32-bit 386, except it usesMOVQrather thanMOVL:gettls(CX) MOVQ g(CX), AX // Move g into AX. MOVQ gm(AX), BX // Move g.m into BX.RegisterBPis callee-save. The assembler automatically insertsBPsave/restore when frame size is larger than zero. UsingBPas a general purpose register is allowed, however it can interfere with sampling-based profiling.ARMThe registersR10andR11are reserved by the compiler and linker.R10points to theg(goroutine) structure. Within assembler source code, this pointer must be referred to asg; the nameR10is not recognized.To make it easier for people and compilers to write assembly, the ARM linker allows general addressing forms and pseudo-operations likeDIVorMODthat may not be expressible using a single hardware instruction. It implements these forms as multiple instructions, often using theR11register to hold temporary values. Hand-written assembly can useR11, but doing so requires being sure that the linker is not also using it to implement any of the other instructions in the function.When defining aTEXT, specifying frame size$-4tells the linker that this is a leaf function that does not need to saveLRon entry.The nameSPalways refers to the virtual stack pointer described earlier. For the hardware register, useR13.Condition code syntax is to append a period and the one- or two-letter code to the instruction, as inMOVW.EQ. Multiple codes may be appended:MOVM.IA.W. The order of the code modifiers is irrelevant.Addressing modes:R0->16R0>>16R0<<16R0@>16: For<<, left shiftR0by 16 bits. The other codes are->(arithmetic right shift),>>(logical right shift), and@>(rotate right).R0->R1R0>>R1R0<R1: For<<, left shiftR0by the count inR1. The other codes are->(arithmetic right shift),>>(logical right shift), and@>(rotate right).[R0,g,R12-R15]: For multi-register instructions, the set comprisingR0,g, andR12throughR15inclusive.(R5, R6): Destination register pair.ARM64R18is the "platform register", reserved on the Apple platform. To prevent accidental misuse, the register is namedR18PLATFORM.R27andR28are reserved by the compiler and linker.R29is the frame pointer.R30is the link register.Instruction modifiers are appended to the instruction following a period. The only modifiers areP(postincrement) andW(preincrement):MOVW.P,MOVW.WAddressing modes:R0->16R0>>16R0<<16R0@>16: These are the same as on the 32-bit ARM.$(8<<12): Left shift the immediate value8by12bits.8(R0): Add the value ofR0and8.(R2)(R0): The location atR0plusR2.R0.UXTBR0.UXTB<, a read-only 64-byte table of 4-byte integer values, and declaresruntime·tlsoffset, a 4-byte, implicitly zeroed variable that contains no pointers. There may be one or two arguments to the directives. If there are two, the first is a bit mask of flags, which can be written as numeric expressions, added or or-ed together, or can be set symbolically for easier absorption by a human. Their values, defined in the standard#includefiletextflag.h, are: ThePCALIGNpseudo-instruction is used to indicate that the next instruction should be aligned to a specified boundary by padding with no-op instructions. It is currently supported on arm64, amd64, ppc64, loong64 and riscv64. For example, the start of theMOVDinstruction below is aligned to 32 bytes:PCALIGN $32 MOVD $2, R0 If a package has any .s files, thengo buildwill direct the compiler to emit a special header calledgoasm.h, which the .s files can then#include. The file contains symbolic#defineconstants for the offsets of Go struct fields, the sizes of Go struct types, and most Goconstdeclarations defined in the current package. Go assembly should avoid making assumptions about the layout of Go types and instead use these constants. This improves the readability of assembly code, and keeps it robust to changes in data layout either in the Go type definitions or in the layout rules used by the Go compiler. Constants are of the formconstname. For example, given the Go declarationconst bufSize = 1024, assembly code can refer to the value of this constant asconstbufSize. Field offsets are of the formtypefield. Struct sizes are of the formtypesize. For example, consider the following Go definition: Assembly can refer to the size of this struct asreadersizeand the offsets of the two fields asreaderbufandreaderr. Hence, if registerR1contains a pointer to areader, assembly can reference therfield asreaderr(R1). If any of these#definenames are ambiguous (for example, a struct with asizefield),#include "goasm.h"will fail with a "redefinition of macro" error. For garbage collection to run correctly, the runtime must know the location of pointers in all global data and in most stack frames. The Go compiler emits this information when compiling Go source files, but assembly programs must define it explicitly. A data symbol marked with theNOPTRflag (see above) is treated as containing no pointers to runtime-allocated data. A data symbol with theRODATAflag is allocated in read-only memory and is therefore treated as implicitly markedNOPTR. A data symbol with a total size smaller than a pointer is also treated as implicitly markedNOPTR. It is not possible to define a symbol containing pointers in an assembly source file; such a symbol must be defined in a Go source file instead. Assembly source can still refer to the symbol by name even withoutDATAandGLOBLdirectives. A good general rule of thumb is to define all non-RODATAsymbols in Go instead of in assembly. Each function also needs annotations giving the location of live pointers in its arguments, results, and local stack frame. For an assembly function with no pointer results and either no local stack frame or no function calls, the only requirement is to define a Go prototype for the function in a Go source file in the same package. The name of the assembly function must not contain the package name component (for example, functionSyscallin packagesyscallshould use the name·Syscallinstead of the equivalent namesyscall·Syscallin itsTEXTdirective). For more complex situations, explicit annotation is needed. These annotations use pseudo-instructions defined in the standard#includefilefuncdata.h. If a function has no arguments and no results, the pointer information can be omitted. This is indicated by an argument size annotation of$n-0on theTEXTinstruction. Otherwise, pointer information must be provided by a Go prototype for the function in a Go source file, even for assembly functions not called directly from Go. (The prototype will also letgovetcheck the argument references.) At the start of the function, the arguments are assumed to be initialized but the results are assumed uninitialized. If the results will hold live pointers during a call instruction, the function should start by zeroing the results and then executing the pseudo-instructionGORESULTSINITIALIZED. This instruction records that the results are now initialized and should be scanned during stack movement and garbage collection. It is typically easier to arrange that assembly functions do not return pointers or do not contain call instructions; no assembly functions in the standard library useGORESULTSINITIALIZED. If a function has no local stack frame, the pointer information can be omitted. This is indicated by a local frame size annotation of$0-non theTEXTinstruction. The pointer information can also be omitted if the function contains no call instructions. Otherwise, the local stack frame must not contain pointers, and the assembly must confirm this fact by executing the pseudo-instructionNOLOCALPOINTERS. Because stack resizing is implemented by moving the stack, the stack pointer may change during any function call: even pointers to stack data must not be kept in local variables. Assembly functions should always be given Go prototypes, both to provide pointer information for the arguments and results and to letgovetcheck that the offsets being used to access them are correct. It is impractical to list all the instructions and other details for each machine. To see what instructions are defined for a given machine, say ARM, look in the source for theobjsupport library for that architecture, located in the directorysrc/cmd/internal/obj/arm. In that directory is a filea.out.go; it contains a long list of constants starting withA, like this: This is the list of instructions and their spellings as known to the assembler and linker for that architecture. Each instruction begins with an initial capitalAin this list, soAANDrepresents the bitwise and instruction,AND(without the leadingA), and is written in assembly source asAND. The enumeration is mostly in alphabetical order. (The architecture-independentAXXX, defined in thecmd/internal/objpackage, represents an invalid instruction). The sequence of theAnames has nothing to do with the actual encoding of the machine instructions. Thecmd/internal/objpackage takes care of that detail. The instructions for both the 386 and AMD64 architectures are listed incmd/internal/obj/x86/a.out.go. The architectures share syntax for common addressing modes such as(R1)(register indirect),4(R1)(register indirect with offset), and$foo(SB)(absolute address). The assembler also supports some (not necessarily all) addressing modes specific to each architecture. The sections below list these. One detail evident in the examples from the previous sections is that data in the instructions flows from left to right:MOVQ$0,CXclearsCX. This rule applies even on architectures where the conventional notation uses the opposite direction. Here follow some descriptions of key Go-specific details for the supported architectures. The runtime pointer to thegstructure is maintained through the value of an otherwise unused (as far as Go is concerned) register in the MMU. In the runtime package, assembly code can includegotls.h, which defines an OS- and architecture-dependent macrogettlsfor accessing this register. Thegettlsmacro takes one argument, which is the register to load thegpointer into. For example, the sequence to loadgandmusingCXlooks like this: Thegettlsmacro is also defined onamd64. Addressing modes: When using the compiler and assembler's-dynlinkor-sharedmodes, any load or store of a fixed memory location such as a global variable must be assumed to overwriteCX. Therefore, to be safe for use with these modes, assembly sources should typically avoid CX except between memory references. The two architectures behave largely the same at the assembler level. Assembly code to access themandgpointers on the 64-bit version is the same as on the 32-bit 386, except it usesMOVQrather thanMOVL: RegisterBPis callee-save. The assembler automatically insertsBPsave/restore when frame size is larger than zero. UsingBPas a general purpose register is allowed, however it can interfere with sampling-based profiling. The registersR10andR11are reserved by the compiler and linker. R10points to theg(goroutine) structure. Within assembler source code, this pointer must be referred to asg; the nameR10is not recognized. To make it easier for people and compilers to write assembly, the ARM linker allows general addressing forms and pseudo-operations likeDIVorMODthat may not be expressible using a single hardware instruction. It implements these forms as multiple instructions, often using theR11register to hold temporary values. Hand-written assembly can useR11, but doing so requires being sure that the linker is not also using it to implement any of the other instructions in the function. When defining aTEXT, specifying frame size$-4tells the linker that this is a leaf function that does not need to saveLRon entry. The nameSPalways refers to the virtual stack pointer described earlier. For the hardware register, useR13. Condition code syntax is to append a period and the one- or two-letter code to the instruction, as inMOVW.EQ. Multiple codes may be appended:MOVM.IA.W. The order of the code modifiers is irrelevant. Addressing modes: R18is the "platform register", reserved on the Apple platform. To prevent accidental misuse, the register is namedR18PLATFORM.R27andR28are reserved by the compiler and linker.R29is the frame pointer.R30is the link register. Instruction modifiers are appended to the instruction following a period. The only modifiers areP(postincrement) andW(preincrement):MOVW.P,MOVW.W Addressing modes: Reference:Go ARM64 Assembly Instructions Reference Manual This assembler is used by GOARCH values ppc64 and ppc64le. Reference:Go PPC64 Assembly Instructions Reference Manual The registersR10andR11are reserved. The assembler uses them to hold temporary values when assembling some instructions. R13points to theg(goroutine) structure. This register must be referred to asg; the nameR13is not recognized. R15points to the stack frame and should typically only be accessed using the virtual registersSPandFP. Load- and store-multiple instructions operate on a range of registers. The range of registers is specified by a start register and an end register. For example,LMG(R9),R5,R7would loadR5,R6andR7with the 64-bit values at0(R9),8(R9)and16(R9)respectively. Storage-and-storage instructions such asMVCandXCare written with the length as the first argument. For example,XC$8,(R9),(R9)would clear eight bytes at the address specified inR9. If a vector instruction takes a length or an index as an argument then it will be the first argument. For example,VLEIF$1,$16,V2will load the value sixteen into index one ofV2. Care should be taken when using vector instructions to ensure that they are available at runtime. To use vector instructions a machine must have both the vector facility (bit 129 in the facility list) and kernel support. Without kernel support a vector instruction will have no effect (it will be equivalent to aNOPinstruction). Addressing modes: General purpose registers are namedR0throughR31, floating point registers areF0throughF31. R30is reserved to point tog.R23is used as a temporary register. In aTEXTdirective, the frame size$-4for MIPS or$-8for MIPS64 instructs the linker not to saveLR. SPrefers to the virtual stack pointer. For the hardware register, useR29. Addressing modes: The value ofGOMIPSenvironment variable (hardfloatorsoftfloat) is made available to assembly code by predefining eitherGOMIPShardfloatorGOMIPSsoftfloat. The value ofGOMIPS64environment variable (hardfloatorsoftfloat) is made available to assembly code by predefining eitherGOMIPS64hardfloatorGOMIPS64softfloat. The assemblers are designed to support the compiler so not all hardware instructions are defined for all architectures: if the compiler doesn't generate it, it might not be there. If you need to use a missing instruction, there are two ways to proceed. One is to update the assembler to support that instruction, which is straightforward but only worthwhile if it's likely the instruction will be used again. Instead, for simple one-off cases, it's possible to use theBYTEandWORDdirectives to lay down explicit data into the instruction stream within aTEXT. Here's how the 386 runtime defines the 64-bit atomic load function. Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected FP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: the highest address within the local stack frame. NOPROF= 1(ForTEXTitems.) Don't profile the marked function. This flag is deprecated. DUPOK= 2It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use. NOSPLIT= 4(ForTEXTitems.) Don't insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space remaining in the current stack segment. Used to protect routines such as the stack splitting code itself. RODATA= 8(ForDATAandGLOBLitems.) Put this data in a read-only section. NOPTR= 16(ForDATAandGLOBLitems.) This data contains no pointers and therefore does not need to be scanned by the garbage collector. WRAPPER= 32(ForTEXTitems.) This is a wrapper function and should not count as disablingrecover. NEEDCTXT= 64(ForTEXTitems.) This function is a closure so it uses its incoming context register. LOCAL= 128This symbol is local to the dynamic shared object. TLSBSS= 256(ForDATAandGLOBLitems.) Put this data in thread local storage. NOFRAME= 512(ForTEXTitems.) Do not insert instructions to allocate a stack frame and save/restore the return address, even if this is not a leaf function. Only valid on functions that declare a frame size of 0. TOPFRAME= 2048(ForTEXTitems.) Function is the outermost frame of the call stack. Traceback should stop at this function. (DI)(BX2): The location at addressDIplusBX2. 64(DI)(BX2): The location at addressDIplusBX2plus 64. These modes accept only 1, 2, 4, and 8 as scale factors. R0->16R0>>16R0<<16R0@>16: For<<, left shiftR0by 16 bits. The other codes are->(arithmetic right shift),>>(logical right shift), and@>(rotate right). R0->R1R0>>R1R0<R1: For<<, left shiftR0by the count inR1. The other codes are->(arithmetic right shift),>>(logical right shift), and@>(rotate right). [R0,g,R12-R15]: For multi-register instructions, the set comprisingR0,g, andR12throughR15inclusive. (R5, R6): Destination register pair. R0->16R0>>16R0<<16R0@>16: These are the same as on the 32-bit ARM. $(8<<12): Left shift the immediate value8by12bits. 8(R0): Add the value ofR0and8. (R2)(R0): The location atR0plusR2. R0.UXTBR0.UXTB<+0x00(SB)/4, $0xf4f8fcff DATA divtab<>+0x04(SB)/4, $0xe6eaedf0 ... DATA divtab<>+0x3c(SB)/4, $0x81828384 GLOBL divtab<>(SB), RODATA, $64 GLOBL runtime·tlsoffset(SB), NOPTR, $4  go PCALIGN $32 MOVD $2, R0  go type reader struct { buf [bufSize]byte r int }  go const ( AAND = obj.ABaseARM + obj.AARCHSPECIFIC + iota AEOR ASUB ARSB AADD ...  go #include "gotls.h" #include "goasm.h" ... gettls(CX) MOVL g(CX), AX // Move g into AX. MOVL gm(AX), BX // Move g.m into BX.  go gettls(CX) MOVQ g(CX), AX // Move g into AX. MOVQ gm(AX), BX // Move g.m into BX.  go // uint64 atomicload64(uint64 volatile addr); // so actually // void atomicload64(uint64 res, uint64 volatile addr); TEXT runtime·atomicload64(SB), NOSPLIT, $0-12 MOVL ptr+0(FP), AX TESTL $7, AX JZ 2(PC) MOVL 0, AX // crash with nil ptr deref LEAL retlo+4(FP), BX // MOVQ (%EAX), %MM0 BYTE $0x0f; BYTE $0x6f; BYTE $0x00 // MOVQ %MM0, 0(%EBX) BYTE $0x0f; BYTE $0x7f; BYTE $0x03 // EMMS BYTE $0x0F; BYTE $0x77 RET  gc MOV runtime math/big FUNCDATA PCDATA go tool objdump 3&1<<2 (3&1)<<2 3&(1<<2) -2 R1 LR FP PC SB SP foo(SB) foo <> foo<>(SB) static foo+4(SB) 0(FP) 8(FP) firstarg+0(FP) secondarg+8(FP) go vet lo hi arglo+0(FP) arghi+4(FP) ret x-8(SP) y-4(SP) -8(SP) R R13 R15 name(SB) name+4(SB) g fmt.Printf math/rand.Int fmt·Printf math∕rand·Int -S ·Int TEXT runtime·profileloop RET TEXTs $24-8 NOSPLIT profileloop DATA GLOBL divtab<> runtime·tlsoffset #include textflag.h NOPROF DUPOK RODATA NOPTR WRAPPER recover NEEDCTXT LOCAL TLSBSS NOFRAME TOPFRAME PCALIGN MOVD go build goasm.h #define const constname const bufSize = 1024 constbufSize typefield typesize readersize readerbuf readerr reader r readerr(R1) size #include "goasm.h" Syscall syscall ·Syscall syscall·Syscall funcdata.h $n-0 GORESULTSINITIALIZED $0-n NOLOCALPOINTERS obj src/cmd/internal/obj/arm a.out.go A AAND AND AXXX cmd/internal/obj cmd/internal/obj/x86/a.out.go (R1) 4(R1) $foo(SB) MOVQ $0, CX gotls.h gettls m (DI)(BX2) DI BX2 64(DI)(BX2) -dynlink -shared MOVL BP R10 R11 DIV MOD $-4 MOVW.EQ MOVM.IA.W R0->16 R0>>16 R0<<16 R0@>16 << R0 -> >> @> R0->R1 R0>>R1 R0<R1 [R0,g,R12-R15] R12 (R5, R6) R18 R18PLATFORM R27 R28 R29 R30 P W MOVW.P MOVW.W $(8<<12) 8 12 8(R0) (R2)(R0) R2 R0.UXTB R0.UXTB<<imm UXTB imm UXTH UXTW UXTX R0.SXTB R0.SXTB<<imm SXTB SXTH SXTW SXTX LDAXP LDP LDXP STLXP STP LMG (R9), R5, R7 R5 R6 0(R9) 8(R9) 16(R9) MVC XC $8, (R9) R9 VLEIF $1, $16, V2 NOP (R5)(R61) 1 R31 F0 F31 R23 $-8 16(R1) 0(R1) GOMIPS hardfloat softfloat GOMIPShardfloat GOMIPSsoftfloat GOMIPS64 GOMIPS64hardfloat GOMIPS64softfloat BYTE WORD 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected