Developing and publishing modules Workflow for developing and publishing modules Design and development Decentralized publishing Package discovery Versioning Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go You can collect related packages into modules, then publish the modules for other developers to use. This topic gives an overview of developing and publishing modules. To support developing, publishing, and using modules, you use: See also When you want to publish your modules for others, you adopt a few conventions to make using those modules easier. The following high-level steps are described in more detail inModule release and versioning workflow. Your module will be easier for developers to find and use if the functions and packages in it form a coherent whole. When you‚Äôre designing a module‚Äôs public API, try to keep its functionality focused and discrete. Also, designing and developing your module with backward compatibility in mind helps its users upgrade while minimizing churn to their own code. You can use certain techniques in code to avoid releasing a version that breaks backward compatibility. For more about those techniques, seeKeeping your modules compatibleon the Go blog. Before you publish a module, you can reference it on the local file system using the replace directive. This makes it easier to write client code that calls functions in the module while the module is still in development. For more information, see ‚ÄúCoding against an unpublished module‚Äù inModule release and versioning workflow. In Go, you publish your module by tagging its code in your repository to make it available for other developers to use. You don‚Äôt need to push your module to a centralized service because Go tools can download your module directly from your repository (located using the module‚Äôs path, which is a URL with the scheme omitted) or from a proxy server. After importing your package in their code, developers use Go tools (including thego getcommand) to download your module‚Äôs code to compile with. To support this model, you follow conventions and best practices that make it possible for Go tools (on behalf of another developer) to retrieve your module‚Äôs source from your repository. For example, Go tools use the module‚Äôs module path you specify, along with the module version number you use to tag the module for release, to locate and download the module for its users. For more about source and publishing conventions and best practices, seeManaging module source. For step-by-step instructions on publishing a module, seePublishing a module. After you‚Äôve published your module and someone has fetched it with Go tools, it will become visible on the Go package discovery site atpkg.go.dev. There, developers can search the site to find it and read its documentation. To begin using the module, a developer imports packages from the module, then runs thego getcommand to download its source code to compile with. For more about how developers find and use modules, seeManaging dependencies. As you revise and improve your module over time, you assign version numbers (based on the semantic versioning model) designed to signal each version‚Äôs stability and backward compatibility. This helps developers using your module determine when the module is stable and whether an upgrade may include significant changes in behavior. You indicate a module‚Äôs version number by tagging the module‚Äôs source in the repository with the number. For more on developing major version updates, seeDeveloping a major version update. For more about how you use the semantic versioning model for Go modules, seeModule version numbering. Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Aworkflowthrough which you develop and publish modules, revising them with new versions over time. SeeWorkflow for developing and publishing modules. Design practicesthat help a module‚Äôs users understand it and upgrade to new versions in a stable way. SeeDesign and development. Adecentralized system for publishingmodules and retrieving their code. You make your module available for other developers to use from your own repository and publish with a version number. SeeDecentralized publishing. Apackage search engineand documentation browser (pkg.go.dev) at which developers can find your module. SeePackage discovery. A moduleversion numbering conventionto communicate expectations of stability and backward compatibility to developers using your module. SeeVersioning. Go toolsthat make it easier for other developers to manage dependencies, including getting your module‚Äôs source, upgrading, and so on. SeeManaging dependencies. If you‚Äôre interested simply in using packages developed by others, this isn‚Äôt the topic for you. Instead, seeManaging dependencies. For a tutorial that includes a few module development basics, seeTutorial: Create a Go module. Design and code the packages that the module will include. Commit code to your repository using conventions that ensure it‚Äôs available to others via Go tools. Publish the module to make it discoverable by developers. Over time, revise the module with versions that use a version numbering convention that signals each version‚Äôs stability and backward compatibility. Copyright Terms of Service Privacy Policy Report an Issue go get üí° Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected