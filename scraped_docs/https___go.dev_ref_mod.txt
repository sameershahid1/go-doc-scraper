Go Modules Reference Introduction Modules, packages, and versions go.modfiles Minimal version selection (MVS) Module graph pruning Workspaces Compatibility with non-module repositories Module-aware commands Module proxies Version control systems Module zip files Private modules Module cache Authenticating modules Environment variables Glossary Module paths Versions Pseudo-versions Major version suffixes Resolving a package to a module Lexical elements Module paths and versions Grammar moduledirective godirective toolchaindirective godebugdirective requiredirective tooldirective excludedirective replacedirective retractdirective Automatic updates Replacement Exclusion Upgrades Downgrade Lazy module loading go.workfiles Lexical elements Grammar godirective toolchaindirective godebugdirective usedirective replacedirective +incompatibleversions Minimal module compatibility Build commands Vendoring go get go install go list -m go mod download go mod edit go mod graph go mod init go mod tidy go mod vendor go mod verify go mod why go version -m go clean -modcache Version queries Module commands outside a module go work init go work edit go work use go work sync GOPROXYprotocol Communicating with proxies Serving modules directly from a proxy Finding a repository for a module path Mapping versions to commits Mapping pseudo-versions to commits Mapping branches and commits to versions Module directories within a repository Special case for LICENSE files Controlling version control tools withGOVCS File path and size constraints Private proxy serving all modules Private proxy serving private modules Direct access to private modules Passing credentials to private proxies Passing credentials to private repositories Privacy go.sum files Checksum database Deprecation Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Modules are how Go manages dependencies. This document is a detailed reference manual for Go’s module system. For an introduction to creating Go projects, seeHow to Write Go Code. For information on using modules, migrating projects to modules, and other topics, see the blog series starting withUsing Go Modules. Amoduleis a collection of packages that are released, versioned, and distributed together. Modules may be downloaded directly from version control repositories or from module proxy servers. A module is identified by amodule path, which is declared in ago.modfile, together with information about the module’s dependencies. Themodule root directoryis the directory that contains thego.modfile. Themain moduleis the module containing the directory where thegocommand is invoked. Eachpackagewithin a module is a collection of source files in the same directory that are compiled together. Apackage pathis the module path joined with the subdirectory containing the package (relative to the module root). For example, the module"golang.org/x/net"contains a package in the directory"html". That package’s path is"golang.org/x/net/html". Amodule pathis the canonical name for a module, declared with themoduledirectivein the module’sgo.modfile. A module’s path is the prefix for package paths within the module. A module path should describe both what the module does and where to find it. Typically, a module path consists of a repository root path, a directory within the repository (usually empty), and a major version suffix (only for major version 2 or higher). If a module might be depended on by other modules, these rules must be followed so that thegocommand can find and download the module. There are also severallexical restrictionson characters allowed in module paths. A module that will never be fetched as a dependency of any other module may use any valid package path for its module path, but must take care not to collide with paths that may be used by the module’s dependencies or the Go standard library. The Go standard library uses package paths that do not contain a dot in the first path element, and thegocommand does not attempt to resolve such paths from network servers. The pathsexampleandtestare reserved for users: they will not be used in the standard library and are suitable for use in self-contained modules, such as those defined in tutorials or example code or created and manipulated as part of a test. Aversionidentifies an immutable snapshot of a module, which may be either areleaseor apre-release. Each version starts with the letterv, followed by a semantic version. SeeSemantic Versioning 2.0.0for details on how versions are formatted, interpreted, and compared. To summarize, a semantic version consists of three non-negative integers (the major, minor, and patch versions, from left to right) separated by dots. The patch version may be followed by an optional pre-release string starting with a hyphen. The pre-release string or patch version may be followed by a build metadata string starting with a plus. For example,v0.0.0,v1.12.134,v8.0.5-pre, andv2.0.9+metaare valid versions. Each part of a version indicates whether the version is stable and whether it is compatible with previous versions. A version is considered unstable if its major version is 0 or it has a pre-release suffix. Unstable versions are not subject to compatibility requirements. For example,v0.2.0may not be compatible withv0.1.0, andv1.5.0-betamay not be compatible withv1.5.0. Go may access modules in version control systems using tags, branches, or revisions that don’t follow these conventions. However, within the main module, thegocommand will automatically convert revision names that don’t follow this standard into canonical versions. Thegocommand will also remove build metadata suffixes (except for+incompatible) as part of this process. This may result in apseudo-version, a pre-release version that encodes a revision identifier (such as a Git commit hash) and a timestamp from a version control system. For example, the commandgo get golang.org/x/net@daa7c041will convert the commit hashdaa7c041into the pseudo-versionv0.0.0-20191109021931-daa7c04131f5. Canonical versions are required outside the main module, and thegocommand will report an error if a non-canonical version likemasterappears in ago.modfile. Apseudo-versionis a specially formattedpre-releaseversionthat encodes information about a specific revision in a version control repository. For example,v0.0.0-20191109021931-daa7c04131f5is a pseudo-version. Pseudo-versions may refer to revisions for which nosemantic version tagsare available. They may be used to test commits before creating version tags, for example, on a development branch. Each pseudo-version has three parts: Each pseudo-version may be in one of three forms, depending on the base version. These forms ensure that a pseudo-version compares higher than its base version, but lower than the next tagged version. More than one pseudo-version may refer to the same commit by using different base versions. This happens naturally when a lower version is tagged after a pseudo-version is written. These forms give pseudo-versions two useful properties: Thegocommand performs several checks to ensure that module authors have control over how pseudo-versions are compared with other versions and that pseudo-versions refer to revisions that are actually part of a module’s commit history. Pseudo-versions never need to be typed by hand. Many commands accept a commit hash or a branch name and will translate it into a pseudo-version (or tagged version if available) automatically. For example: Starting with major version 2, module paths must have amajor version suffixlike/v2that matches the major version. For example, if a module has the pathexample.com/modatv1.0.0, it must have the pathexample.com/mod/v2at versionv2.0.0. Major version suffixes implement theimport compatibility rule: If an old package and a new package have the same import path, the new package must be backwards compatible with the old package. By definition, packages in a new major version of a module are not backwards compatible with the corresponding packages in the previous major version. Consequently, starting withv2, packages need new import paths. This is accomplished by adding a major version suffix to the module path. Since the module path is a prefix of the import path for each package within the module, adding the major version suffix to the module path provides a distinct import path for each incompatible version. Major version suffixes are not allowed at major versionsv0orv1. There is no need to change the module path betweenv0andv1becausev0versions are unstable and have no compatibility guarantee. Additionally, for most modules,v1is backwards compatible with the lastv0version; av1version acts as a commitment to compatibility, rather than an indication of incompatible changes compared withv0. As a special case, modules paths starting withgopkg.in/must always have a major version suffix, even atv0andv1. The suffix must start with a dot rather than a slash (for example,gopkg.in/yaml.v2). Major version suffixes let multiple major versions of a module coexist in the same build. This may be necessary due to adiamond dependency problem. Ordinarily, if a module is required at two different versions by transitive dependencies, the higher version will be used. However, if the two versions are incompatible, neither version will satisfy all clients. Since incompatible versions must have different major version numbers, they must also have different module paths due to major version suffixes. This resolves the conflict: modules with distinct suffixes are treated as separate modules, and their packages—even packages in same subdirectory relative to their module roots—are distinct. Many Go projects released versions atv2or higher without using a major version suffix before migrating to modules (perhaps before modules were even introduced). These versions are annotated with a+incompatiblebuild tag (for example,v2.0.0+incompatible). SeeCompatibility with non-module repositoriesfor more information. When thegocommand loads a package using apackage path, it needs to determine which module provides the package. Thegocommand starts by searching thebuild listfor modules with paths that are prefixes of the package path. For example, if the packageexample.com/a/bis imported, and the moduleexample.com/ais in the build list, thegocommand will check whetherexample.com/acontains the package, in the directoryb. At least one file with the.goextension must be present in a directory for it to be considered a package.Build constraintsare not applied for this purpose. If exactly one module in the build list provides the package, that module is used. If no modules provide the package or if two or more modules provide the package, thegocommand reports an error. The-mod=modflag instructs thegocommand to attempt to find new modules providing missing packages and to updatego.modandgo.sum. Thego getandgo mod tidycommands do this automatically. When thegocommand looks up a new module for a package path, it checks theGOPROXYenvironment variable, which is a comma-separated list of proxy URLs or the keywordsdirectoroff. A proxy URL indicates thegocommand should contact amodule proxyusing theGOPROXYprotocol.directindicates that thegocommand shouldcommunicate with a version control system.offindicates that no communication should be attempted. TheGOPRIVATEandGONOPROXYenvironment variablescan also be used to control this behavior. For each entry in theGOPROXYlist, thegocommand requests the latest version of each module path that might provide the package (that is, each prefix of the package path). For each successfully requested module path, thegocommand will download the module at the latest version and check whether the module contains the requested package. If one or more modules contain the requested package, the module with the longest path is used. If one or more modules are found but none contain the requested package, an error is reported. If no modules are found, thegocommand tries the next entry in theGOPROXYlist. If no entries are left, an error is reported. For example, suppose thegocommand is looking for a module that provides the packagegolang.org/x/net/html, andGOPROXYis set tohttps://corp.example.com,https://proxy.golang.org. Thegocommand may make the following requests: After a suitable module has been found, thegocommand will add a newrequirementwith the new module’s path and version to the main module’sgo.modfile. This ensures that when the same package is loaded in the future, the same module will be used at the same version. If the resolved package is not imported by a package in the main module, the new requirement will have an// indirectcomment. A module is defined by a UTF-8 encoded text file namedgo.modin its root directory. Thego.modfile is line-oriented. Each line holds a single directive, made up of a keyword followed by arguments. For example: The leading keyword can be factored out of adjacent lines to create a block, like in Go imports. Thego.modfile is designed to be human readable and machine writable. Thegocommand provides several subcommands that changego.modfiles. For example,go getcan upgrade or downgrade specific dependencies. Commands that load the module graph willautomatically updatego.modwhen needed.go mod editcan perform low-level edits. Thegolang.org/x/mod/modfilepackage can be used by Go programs to make the same changes programmatically. Ago.modfile is required for themain module, and for anyreplacement modulespecified with a local file path. However, a module that lacks an explicitgo.modfile may still berequiredas a dependency, or used as a replacement specified with a module path and version; seeCompatibility with non-module repositories. When ago.modfile is parsed, its content is broken into a sequence of tokens. There are several kinds of tokens: whitespace, comments, punctuation, keywords, identifiers, and strings. White spaceconsists of spaces (U+0020), tabs (U+0009), carriage returns (U+000D), and newlines (U+000A). White space characters other than newlines have no effect except to separate tokens that would otherwise be combined. Newlines are significant tokens. Commentsstart with//and run to the end of a line./ /comments are not allowed. Punctuationtokens include(,), and=>. Keywordsdistinguish different kinds of directives in ago.modfile. Allowed keywords aremodule,go,require,replace,exclude, andretract. Identifiersare sequences of non-whitespace characters, such as module paths or semantic versions. Stringsare quoted sequences of characters. There are two kinds of strings: interpreted strings beginning and ending with quotation marks (", U+0022) and raw strings beginning and ending with grave accents (, U+0060). Interpreted strings may contain escape sequences consisting of a backslash (\, U+005C) followed by another character. An escaped quotation mark (\") does not terminate an interpreted string. The unquoted value of an interpreted string is the sequence of characters between quotation marks with each escape sequence replaced by the character following the backslash (for example,\"is replaced by",\nis replaced byn). In contrast, the unquoted value of a raw string is simply the sequence of characters between grave accents; backslashes have no special meaning within raw strings. Identifiers and strings are interchangeable in thego.modgrammar. Most identifiers and strings in ago.modfile are either module paths or versions. A module path must satisfy the following requirements: If the module path appears in arequiredirective and is not replaced, or if the module paths appears on the right side of areplacedirective, thegocommand may need to download modules with that path, and some additional requirements must be satisfied. Versions ingo.modfiles may becanonicalor non-canonical. A canonical version starts with the letterv, followed by a semantic version following theSemantic Versioning 2.0.0specification. SeeVersionsfor more information. Most other identifiers and strings may be used as non-canonical versions, though there are some restrictions to avoid problems with file systems, repositories, andmodule proxies. Non-canonical versions are only allowed in the main module’sgo.modfile. Thegocommand will attempt to replace each non-canonical version with an equivalent canonical version when it automaticallyupdatesthego.modfile. In places where a module path is associated with a version (as inrequire,replace, andexcludedirectives), the final path element must be consistent with the version. SeeMajor version suffixes. go.modsyntax is specified below using Extended Backus-Naur Form (EBNF). See theNotation section in the Go Language Specificationfor details on EBNF syntax. Newlines, identifiers, and strings are denoted withnewline,ident, andstring, respectively. Module paths and versions are denoted withModulePathandVersion. Amoduledirective defines the main module’spath. Ago.modfile must contain exactly onemoduledirective. Example: A module can be marked as deprecated in a block of comments containing the stringDeprecated:(case-sensitive) at the beginning of a paragraph. The deprecation message starts after the colon and runs to the end of the paragraph. The comments may appear immediately before themoduledirective or afterward on the same line. Example: Since Go 1.17,go list -m -uchecks for information on all deprecated modules in thebuild list.go getchecks for deprecated modules needed to build packages named on the command line. When thegocommand retrieves deprecation information for a module, it loads thego.modfile from the version matching the@latestversion querywithout consideringretractionsorexclusions. Thegocommand loads the list ofretracted versionsfrom the samego.modfile. To deprecate a module, an author may add a// Deprecated:comment and tag a new release. The author may change or remove the deprecation message in a higher release. A deprecation applies to all minor versions of a module. Major versions higher thanv2are considered separate modules for this purpose, since theirmajor version suffixesgive them distinct module paths. Deprecation messages are intended to inform users that the module is no longer supported and to provide migration instructions, for example, to the latest major version. Individual minor and patch versions cannot be deprecated;retractmay be more appropriate for that. Agodirective indicates that a module was written assuming the semantics of a given version of Go. The version must be a validGo version, such as1.14,1.21rc1, or1.23.0. Thegodirective sets the minimum version of Go required to use this module. Before Go 1.21, the directive was advisory only; now it is a mandatory requirement: Go toolchains refuse to use modules declaring newer Go versions. Thegodirective is an input into selecting which Go toolchain to run. See “Go toolchains” for details. Thegodirective affects use of new language features: Thegodirective also affects the behavior of thegocommand: Ago.modfile may contain at most onegodirective. Most commands will add agodirective with the current Go version if one is not present. If thegodirective is missing,go 1.16is assumed. Example: Atoolchaindirective declares a suggested Go toolchain to use with a module. The suggested Go toolchain’s version cannot be less than the required Go version declared in thegodirective. Thetoolchaindirective only has an effect when the module is the main module and the default toolchain’s version is less than the suggested toolchain’s version. For reproducibility, thegocommand writes its own toolchain name in atoolchainline any time it is updating thegoversion in thego.modfile (usually duringgo get). For details, see “Go toolchains”. Example: Agodebugdirective declares a singleGODEBUG settingto apply when this module is the main module. There can be more than one such line, and they can be factored. It is an error for the main module to name a GODEBUG key that does not exist. The effect ofgodebug key=valueis as if every main package being compiled contained a source file that listed//go:debug key=value. Example: Arequiredirective declares a minimum required version of a given module dependency. For each required module version, thegocommand loads thego.modfile for that version and incorporates the requirements from that file. Once all requirements have been loaded, thegocommand resolves them usingminimal version selection (MVS)to produce thebuild list. Thegocommand automatically adds// indirectcomments for some requirements. An// indirectcomment indicates that no package from the required module is directly imported by any package in themain module. If thegodirectivespecifiesgo 1.16or lower, thegocommand adds an indirect requirement when the selected version of a module is higher than what is already implied (transitively) by the main module’s other dependencies. That may occur because of an explicit upgrade (go get -u ./...), removal of some other dependency that previously imposed the requirement (go mod tidy), or a dependency that imports a package without a corresponding requirement in its owngo.modfile (such as a dependency that lacks ago.modfile altogether). Atgo 1.17and above, thegocommand adds an indirect requirement for each module that provides any package imported (evenindirectly) by a package or test in the main module or passed as an argument togo get. These more comprehensive requirements enablemodule graph pruningandlazy module loading. Example: Atooldirective adds a package as a dependency of the current module. It also makes it available to run withgo toolwhen the current working directory is within this module, or within a workspace that contains this module. If the tool package is not in the current module, arequiredirective must be present that specifies the version of the tool to use. Thetoolmeta-pattern resolves to the list of tools defined in the current module’sgo.mod, or in workspace mode to the union of all tools defined in all modules in the workspace. Example: Anexcludedirective prevents a module version from being loaded by thegocommand. Since Go 1.16, if a version referenced by arequiredirective in anygo.modfile is excluded by anexcludedirective in the main module’sgo.modfile, the requirement is ignored. This may cause commands likego getandgo mod tidyto add new requirements on higher versions togo.mod, with an// indirectcomment if appropriate. Before Go 1.16, if an excluded version was referenced by arequiredirective, thegocommand listed available versions for the module (as shown withgo list -m -versions) and loaded the next higher non-excluded version instead. This could result in non-deterministic version selection, since the next higher version could change over time. Both release and pre-release versions were considered for this purpose, but pseudo-versions were not. If there were no higher versions, thegocommand reported an error. excludedirectives only apply in the main module’sgo.modfile and are ignored in other modules. SeeMinimal version selectionfor details. Example: Areplacedirective replaces the contents of a specific version of a module, or all versions of a module, with contents found elsewhere. The replacement may be specified with either another module path and version, or a platform-specific file path. If a version is present on the left side of the arrow (=>), only that specific version of the module is replaced; other versions will be accessed normally. If the left version is omitted, all versions of the module are replaced. If the path on the right side of the arrow is an absolute or relative path (beginning with./or../), it is interpreted as the local file path to the replacement module root directory, which must contain ago.modfile. The replacement version must be omitted in this case. If the path on the right side is not a local path, it must be a valid module path. In this case, a version is required. The same module version must not also appear in the build list. Regardless of whether a replacement is specified with a local path or module path, if the replacement module has ago.modfile, itsmoduledirective must match the module path it replaces. replacedirectives only apply in the main module’sgo.modfile and are ignored in other modules. SeeMinimal version selectionfor details. If there are multiple main modules, all main modules’go.modfiles apply. Conflictingreplacedirectives across main modules are disallowed, and must be removed or overridden in areplace in thego.work file. Note that areplacedirective alone does not add a module to themodule graph. Arequiredirectivethat refers to a replaced module version is also needed, either in the main module’sgo.modfile or a dependency’sgo.modfile. Areplacedirective has no effect if the module version on the left side is not required. Example: Aretractdirective indicates that a version or range of versions of the module defined bygo.modshould not be depended upon. Aretractdirective is useful when a version was published prematurely or a severe problem was discovered after the version was published. Retracted versions should remain available in version control repositories and onmodule proxiesto ensure that builds that depend on them are not broken. The wordretractis borrowed from academic literature: a retracted research paper is still available, but it has problems and should not be the basis of future work. When a module version is retracted, users will not upgrade to it automatically usinggo get,go mod tidy, or other commands. Builds that depend on retracted versions should continue to work, but users will be notified of retractions when they check for updates withgo list -m -uor update a related module withgo get. To retract a version, a module author should add aretractdirective togo.mod, then publish a new version containing that directive. The new version must be higher than other release or pre-release versions; that is, the@latestversion queryshould resolve to the new version before retractions are considered. Thegocommand loads and applies retractions from the version shown bygo list -m -retracted $modpath@latest(where$modpathis the module path). Retracted versions are hidden from the version list printed bygo list -m -versionsunless the-retractedflag is used. Retracted versions are excluded when resolving version queries like@>=v1.2.3or@latest. A version containing retractions may retract itself. If the highest release or pre-release version of a module retracts itself, the@latestquery resolves to a lower version after retracted versions are excluded. As an example, consider a case where the author of moduleexample.com/mpublishes versionv1.0.0accidentally. To prevent users from upgrading tov1.0.0, the author can add tworetractdirectives togo.mod, then tagv1.0.1with the retractions. When a user runsgo get example.com/m@latest, thegocommand reads retractions fromv1.0.1, which is now the highest version. Bothv1.0.0andv1.0.1are retracted, so thegocommand will upgrade (or downgrade!) to the next highest version, perhapsv0.9.5. retractdirectives may be written with either a single version (likev1.0.0) or with a closed interval of versions with an upper and lower bound, delimited by[and](like[v1.1.0, v1.2.0]). A single version is equivalent to an interval where the upper and lower bound are the same. Like other directives, multipleretractdirectives may be grouped together in a block delimited by(at the end of a line and)on its own line. Eachretractdirective should have a comment explaining the rationale for the retraction, though this is not mandatory. Thegocommand may display rationale comments in warnings about retracted versions and ingo listoutput. A rationale comment may be written immediately above aretractdirective (without a blank line in between) or afterward on the same line. If a comment appears above a block, it applies to allretractdirectives within the block that don’t have their own comments. A rationale comment may span multiple lines. Examples: Theretractdirective was added in Go 1.16. Go 1.15 and lower will report an error if aretractdirective is written in themain module’sgo.modfile and will ignoreretractdirectives ingo.modfiles of dependencies. Most commands report an error ifgo.modis missing information or doesn’t accurately reflect reality. Thego getandgo mod tidycommands may be used to fix most of these problems. Additionally, the-mod=modflag may be used with most module-aware commands (go build,go test, and so on) to instruct thegocommand to fix problems ingo.modandgo.sumautomatically. For example, consider thisgo.modfile: The update triggered with-mod=modrewrites non-canonical version identifiers tocanonicalsemver form, soexample.com/A’sv1becomesv1.0.0, andexample.com/E’sdevbecomes the pseudo-version for the latest commit on thedevbranch, perhapsv0.0.0-20180523231146-b3f5c0f6e5f1. The update modifies requirements to respect exclusions, so the requirement on the excludedexample.com/D v1.2.3is updated to use the next available version ofexample.com/D, perhapsv1.2.4orv1.3.0. The update removes redundant or misleading requirements. For example, ifexample.com/A v1.0.0itself requiresexample.com/B v1.2.0andexample.com/C v1.0.0, thengo.mod’s requirement ofexample.com/B v1.0.0is misleading (superseded byexample.com/A’s need forv1.2.0), and its requirement ofexample.com/C v1.0.0is redundant (implied byexample.com/A’s need for the same version), so both will be removed. If the main module contains packages that directly import packages fromexample.com/Borexample.com/C, then the requirements will be kept but updated to the actual versions being used. Finally, the update reformats thego.modin a canonical formatting, so that future mechanical changes will result in minimal diffs. Thegocommand will not updatego.modif only formatting changes are needed. Because the module graph defines the meaning of import statements, any commands that load packages also usego.modand can therefore update it, includinggo build,go get,go install,go list,go test,go mod tidy. In Go 1.15 and lower, the-mod=modflag was enabled by default, so updates were performed automatically. Since Go 1.16, thegocommand acts as if-mod=readonlywere set instead: if any changes togo.modare needed, thegocommand reports an error and suggests a fix. Go uses an algorithm calledMinimal version selection (MVS)to select a set of module versions to use when building packages. MVS is described in detail inMinimal Version Selectionby Russ Cox. Conceptually, MVS operates on a directed graph of modules, specified withgo.modfiles. Each vertex in the graph represents a module version. Each edge represents a minimum required version of a dependency, specified using arequiredirective. The graph may be modified byexcludeandreplacedirectives in thego.modfile(s) of the main module(s) and byreplacedirectives in thego.workfile. MVS produces thebuild listas output, the list of module versions used for a build. MVS starts at the main modules (special vertices in the graph that have no version) and traverses the graph, tracking the highest required version of each module. At the end of the traversal, the highest required versions comprise the build list: they are the minimum versions that satisfy all requirements. The build list may be inspected with the commandgo list -m all. Unlike other dependency management systems, the build list is not saved in a “lock” file. MVS is deterministic, and the build list doesn’t change when new versions of dependencies are released, so MVS is used to compute it at the beginning of every module-aware command. Consider the example in the diagram below. The main module requires module A at version 1.2 or higher and module B at version 1.2 or higher. A 1.2 and B 1.2 require C 1.3 and C 1.4, respectively. C 1.3 and C 1.4 both require D 1.2. MVS visits and loads thego.modfile for each of the module versions highlighted in blue. At the end of the graph traversal, MVS returns a build list containing the bolded versions: A 1.2, B 1.2, C 1.4, and D 1.2. Note that higher versions of B and D are available but MVS does not select them, since nothing requires them. The content of a module (including itsgo.modfile) may be replaced using areplacedirectivein a main module’sgo.modfile or a workspace’sgo.workfile. Areplacedirective may apply to a specific version of a module or to all versions of a module. Replacements change the module graph, since a replacement module may have different dependencies than replaced versions. Consider the example below, where C 1.4 has been replaced with R. R depends on D 1.3 instead of D 1.2, so MVS returns a build list containing A 1.2, B 1.2, C 1.4 (replaced with R), and D 1.3. A module may also be excluded at specific versions using anexcludedirectivein the main module’sgo.modfile. Exclusions also change the module graph. When a version is excluded, it is removed from the module graph, and requirements on it are redirected to the next higher version. Consider the example below. C 1.3 has been excluded. MVS will act as if A 1.2 required C 1.4 (the next higher version) instead of C 1.3. Thego getcommand may be used to upgrade a set of modules. To perform an upgrade, thegocommand changes the module graph before running MVS by adding edges from visited versions to upgraded versions. Consider the example below. Module B may be upgraded from 1.2 to 1.3, C may be upgraded from 1.3 to 1.4, and D may be upgraded from 1.2 to 1.3. Upgrades (and downgrades) may add or remove indirect dependencies. In this case, E 1.1 and F 1.1 appear in the build list after the upgrade, since E 1.1 is required by B 1.3. To preserve upgrades, thegocommand updates the requirements ingo.mod. It will change the requirement on B to version 1.3. It will also add requirements on C 1.4 and D 1.3 with// indirectcomments, since those versions would not be selected otherwise. Thego getcommand may also be used to downgrade a set of modules. To perform a downgrade, thegocommand changes the module graph by removing versions above the downgraded versions. It also removes versions of other modules that depend on removed versions, since they may not be compatible with the downgraded versions of their dependencies. If the main module requires a module version removed by downgrading, the requirement is changed to a previous version that has not been removed. If no previous version is available, the requirement is dropped. Consider the example below. Suppose that a problem was found with C 1.4, so we downgrade to C 1.3. C 1.4 is removed from the module graph. B 1.2 is also removed, since it requires C 1.4 or higher. The main module’s requirement on B is changed to 1.1. go getcan also remove dependencies entirely, using an@nonesuffix after an argument. This works similarly to a downgrade. All versions of the named module are removed from the module graph. If the main module is atgo 1.17or higher, themodule graphused forminimal version selectionincludes only theimmediaterequirements for each module dependency that specifiesgo 1.17or higher in its owngo.modfile, unless that version of the module is also (transitively) required by someotherdependency atgo 1.16or below. (Thetransitivedependencies ofgo 1.17dependencies arepruned outof the module graph.) Since ago 1.17go.modfile includes arequire directivefor every dependency needed to build any package or test in that module, the pruned module graph includes all of the dependencies needed togo buildorgo testthe packages in any dependency explicitly required by themain module. A module that isnotneeded to build any package or test in a given module cannot affect the run-time behavior of its packages, so the dependencies that are pruned out of the module graph would only cause interference between otherwise-unrelated modules. Modules whose requirements have been pruned out still appear in the module graph and are still reported bygo list -m all: theirselected versionsare known and well-defined, and packages can be loaded from those modules (for example, as transitive dependencies of tests loaded from other modules). However, since thegocommand cannot easily identify which dependencies of these modules are satisfied, the arguments togo buildandgo testcannot include packages from modules whose requirements have been pruned out.go getpromotes the module containing each named package to an explicit dependency, allowinggo buildorgo testto be invoked on that package. Because Go 1.16 and earlier did not support module graph pruning, the full transitive closure of dependencies — including transitivego 1.17dependencies — is still included for each module that specifiesgo 1.16or lower. (Atgo 1.16and below, thego.modfile includes onlydirect dependencies, so a much larger graph must be loaded to ensure that all indirect dependencies are included.) Thego.sumfilerecorded bygo mod tidyfor a module by default includes checksums needed by the Go versionone belowthe version specified in itsgodirective. So ago 1.17module includes checksums needed for the full module graph loaded by Go 1.16, but ago 1.18module will include only the checksums needed for the pruned module graph loaded by Go 1.17. The-compatflag can be used to override the default version (for example, to prune thego.sumfile more aggressively in ago 1.17module). Seethe design documentfor more detail. The more comprehensive requirements added for module graph pruning also enable another optimization when working within a module. If the main module is atgo 1.17or higher, thegocommand avoids loading the complete module graph until (and unless) it is needed. Instead, it loads only the main module’sgo.modfile, then attempts to load the packages to be built using only those requirements. If a package to be imported (for example, a dependency of a test for a package outside the main module) is not found among those requirements, then the rest of the module graph is loaded on demand. If all imported packages can be found without loading the module graph, thegocommand then loads thego.modfiles foronlythe modules containing those packages, and their requirements are checked against the requirements of the main module to ensure that they are locally consistent. (Inconsistencies can arise due to version-control merges, hand-edits, and changes in modules that have beenreplacedusing local filesystem paths.) Aworkspaceis a collection of modules on disk that are used as the main modules when runningminimal version selection (MVS). A workspace can be declared in ago.workfilethat specifies relative paths to the module directories of each of the modules in the workspace. When nogo.workfile exists, the workspace consists of the single module containing the current directory. Mostgosubcommands that work with modules operate on the set of modules determined by the current workspace.go mod init,go mod why,go mod edit,go mod tidy,go mod vendor, andgo getalways operate on a single main module. A command determines whether it is in a workspace context by first examining theGOWORKenvironment variable. IfGOWORKis set tooff, the command will be in a single-module context. If it is empty or not provided, the command will search the current working directory, and then successive parent directories, for a filego.work. If a file is found, the command will operate in the workspace it defines; otherwise, the workspace will include only the module containing the working directory. IfGOWORKnames a path to an existing file that ends in .work, workspace mode will be enabled. Any other value is an error. You can use thego env GOWORKcommand to determine whichgo.workfile thegocommand is using.go env GOWORKwill be empty if thegocommand is not in workspace mode. A workspace is defined by a UTF-8 encoded text file namedgo.work. Thego.workfile is line oriented. Each line holds a single directive, made up of a keyword followed by arguments. For example: As ingo.modfiles, a leading keyword can be factored out of adjacent lines to create a block. Thegocommand provides several subcommands for manipulatinggo.workfiles.go work initcreates newgo.workfiles.go work useadds module directories to thego.workfile.go work editperforms low-level edits. Thegolang.org/x/mod/modfilepackage can be used by Go programs to make the same changes programmatically. The go command will maintain ago.work.sumfile that keeps track of hashes used by the workspace that are not in collective workspace modules’ go.sum files. It is generally inadvisable to commit go.work files into version control systems, for two reasons: That said, there are some cases where committing ago.workfile makes sense. For example, when the modules in a repository are developed exclusively with each other but not together with external modules, there may not be a reason the developer would want to use a different combination of modules in a workspace. In that case, the module author should ensure the individual modules are tested and released properly. Lexical elements ingo.workfiles are defined in exactly the same wayas forgo.mod files. go.worksyntax is specified below using Extended Backus-Naur Form (EBNF). See theNotation section in the Go Language Specificationfor details on EBNF syntax. Newlines, identifiers, and strings are denoted withnewline,ident, andstring, respectively. Module paths and versions are denoted withModulePathandVersion. Module paths and versions are specified in exactly the same wayas forgo.mod files. Agodirective is required in a validgo.workfile. The version must be a valid Go release version: a positive integer followed by a dot and a non-negative integer (for example,1.18,1.19). Thegodirective indicates the go toolchain version with which thego.workfile is intended to work. If changes are made to thego.workfile format, future versions of the toolchain will interpret the file according to its indicated version. Ago.workfile may contain at most onegodirective. Example: Atoolchaindirective declares a suggested Go toolchain to use in a workspace. It only has an effect when the default toolchain is older than the suggested toolchain. For details, see “Go toolchains”. Example: Agodebugdirective declares a singleGODEBUG settingto apply when working in this workspace. The syntax and effect is the same as thego.modfile’sgodebugdirective. When a workspace is in use,godebugdirectives ingo.modfiles are ignored. Auseadds a module on disk to the set of main modules in a workspace. Its argument is a relative path to the directory containing the module’sgo.modfile. Ausedirective does not add modules contained in subdirectories of its argument directory. Those modules may be added by the directory containing theirgo.modfile in separateusedirectives. Example: Similar to areplacedirective in ago.modfile, areplacedirective in ago.workfile replaces the contents of a specific version of a module, or all versions of a module, with contents found elsewhere. A wildcard replace ingo.workoverrides a version-specificreplacein ago.modfile. replacedirectives ingo.workfiles override any replaces of the same module or module version in workspace modules. Example: To ensure a smooth transition fromGOPATHto modules, thegocommand can download and build packages in module-aware mode from repositories that have not migrated to modules by adding ago.modfile. When thegocommand downloads a module at a given versiondirectlyfrom a repository, it looks up a repository URL for the module path, maps the version to a revision within the repository, then extracts an archive of the repository at that revision. If themodule’s pathis equal to therepository root path, and the repository root directory does not contain ago.modfile, thegocommand synthesizes ago.modfile in the module cache that contains amoduledirectiveand nothing else. Since syntheticgo.modfiles do not containrequiredirectivesfor their dependencies, other modules that depend on them may need additionalrequiredirectives (with// indirectcomments) to ensure each dependency is fetched at the same version on every build. When thegocommand downloads a module from aproxy, it downloads thego.modfile separately from the rest of the module content. The proxy is expected to serve a syntheticgo.modfile if the original module didn’t have one. A module released at major version 2 or higher must have a matchingmajor version suffixon its module path. For example, if a module is released atv2.0.0, its path must have a/v2suffix. This allows thegocommand to treat multiple major versions of a project as distinct modules, even if they’re developed in the same repository. The major version suffix requirement was introduced when module support was added to thegocommand, and many repositories had already tagged releases with major version2or higher before that. To maintain compatibility with these repositories, thegocommand adds an+incompatiblesuffix to versions with major version 2 or higher without ago.modfile.+incompatibleindicates that a version is part of the same module as versions with lower major version numbers; consequently, thegocommand may automatically upgrade to higher+incompatibleversions even though it may break the build. Consider the example requirement below: The versionv4.1.2+incompatiblerefers to thesemantic version tagv4.1.2in the repository that provides the moduleexample.com/m. The module must be in the repository root directory (that is, therepository root pathmust also beexample.com/m), and ago.modfile must not be present. The module may have versions with lower major version numbers likev1.5.2, and thegocommand may upgrade automatically tov4.1.2+incompatiblefrom those versions (seeminimal version selection (MVS)for information on how upgrades work). A repository that migrates to modules after versionv2.0.0is tagged should usually release a new major version. In the example above, the author should create a module with the pathexample.com/m/v5and should release versionv5.0.0. The author should also update imports of packages in the module to use the prefixexample.com/m/v5instead ofexample.com/m. SeeGo Modules: v2 and Beyondfor a more detailed example. Note that the+incompatiblesuffix should not appear on a tag in a repository; a tag likev4.1.2+incompatiblewill be ignored. The suffix only appears in versions used by thegocommand. SeeMapping versions to commitsfor details on the distinction between versions and tags. Note also that the+incompatiblesuffix may appear onpseudo-versions. For example,v2.0.1-20200722182040-012345abcdef+incompatiblemay be a valid pseudo-version. A module released at major version 2 or higher is required to have amajor version suffixon itsmodule path. The module may or may not be developed in amajor version subdirectorywithin its repository. This has implications for packages that import packages within the module when buildingGOPATHmode. Normally inGOPATHmode, a package is stored in a directory matching itsrepository’s root pathjoined with its directory within the repository. For example, a package in the repository with root pathexample.com/repoin the subdirectorysubwould be stored in$GOPATH/src/example.com/repo/suband would be imported asexample.com/repo/sub. For a module with a major version suffix, one might expect to find the packageexample.com/repo/v2/subin the directory$GOPATH/src/example.com/repo/v2/sub. This would require the module to be developed in thev2subdirectory of its repository. Thegocommand supports this but does not require it (seeMapping versions to commits). If a module isnotdeveloped in a major version subdirectory, then its directory inGOPATHwill not contain the major version suffix, and its packages may be imported without the major version suffix. In the example above, the package would be found in the directory$GOPATH/src/example.com/repo/suband would be imported asexample.com/repo/sub. This creates a problem for packages intended to be built in both module mode andGOPATHmode: module mode requires a suffix, whileGOPATHmode does not. To fix this,minimal module compatibilitywas added in Go 1.11 and was backported to Go 1.9.7 and 1.10.3. When an import path is resolved to a directory inGOPATHmode: This rules allow packages that have been migrated to modules to import other packages that have been migrated to modules when built inGOPATHmode even when a major version subdirectory was not used. Mostgocommands may run inModule-aware modeorGOPATHmode. In module-aware mode, thegocommand usesgo.modfiles to find versioned dependencies, and it typically loads packages out of themodule cache, downloading modules if they are missing. InGOPATHmode, thegocommand ignores modules; it looks invendordirectoriesand inGOPATHto find dependencies. As of Go 1.16, module-aware mode is enabled by default, regardless of whether ago.modfile is present. In lower versions, module-aware mode was enabled when ago.modfile was present in the current directory or any parent directory. Module-aware mode may be controlled with theGO111MODULEenvironment variable, which can be set toon,off, orauto. In module-aware mode,GOPATHno longer defines the meaning of imports during a build, but it still stores downloaded dependencies (inGOPATH/pkg/mod; seeModule cache) and installed commands (inGOPATH/bin, unlessGOBINis set). All commands that load information about packages are module-aware. This includes: When run in module-aware mode, these commands usego.modfiles to interpret import paths listed on the command line or written in Go source files. These commands accept the following flags, common to all module commands. When using modules, thegocommand typically satisfies dependencies by downloading modules from their sources into the module cache, then loading packages from those downloaded copies.Vendoringmay be used to allow interoperation with older versions of Go, or to ensure that all files used for a build are stored in a single file tree. Thego mod vendorcommand constructs a directory namedvendorin themain module’sroot directory containing copies of all packages needed to build and test packages in the main module. Packages that are only imported by tests of packages outside the main module are not included. As withgo mod tidyand other module commands,build constraintsexcept forignoreare not considered when constructing thevendordirectory. go mod vendoralso creates the filevendor/modules.txtthat contains a list of vendored packages and the module versions they were copied from. When vendoring is enabled, this manifest is used as a source of module version information, as reported bygo list -mandgo version -m. When thegocommand readsvendor/modules.txt, it checks that the module versions are consistent withgo.mod. Ifgo.modhas changed sincevendor/modules.txtwas generated, thegocommand will report an error.go mod vendorshould be run again to update thevendordirectory. If thevendordirectory is present in the main module’s root directory, it will be used automatically if thegoversionin the main module’sgo.modfileis1.14or higher. To explicitly enable vendoring, invoke thegocommand with the flag-mod=vendor. To disable vendoring, use the flag-mod=readonlyor-mod=mod. When vendoring is enabled,build commandslikego buildandgo testload packages from thevendordirectory instead of accessing the network or the local module cache. Thego list -mcommand only prints information about modules listed ingo.mod.go modcommands such asgo mod downloadandgo mod tidydo not work differently when vendoring is enabled and will still download modules and access the module cache.go getalso does not work differently when vendoring is enabled. Unlikevendoring inGOPATHmode, thegocommand ignores vendor directories in locations other than the main module’s root directory. Additionally, since vendor directories in other modules are not used, thegocommand does not include vendor directories when buildingmodule zip files(but see known bugs#31562and#37397). Usage: Examples: Thego getcommand updates module dependencies in thego.modfilefor themain module, then builds and installs packages listed on the command line. The first step is to determine which modules to update.go getaccepts a list of packages, package patterns, and module paths as arguments. If a package argument is specified,go getupdates the module that provides the package. If a package pattern is specified (for example,allor a path with a...wildcard),go getexpands the pattern to a set of packages, then updates the modules that provide the packages. If an argument names a module but not a package (for example, the modulegolang.org/x/nethas no package in its root directory),go getwill update the module but will not build a package. If no arguments are specified,go getacts as if.were specified (the package in the current directory); this may be used together with the-uflag to update modules that provide imported packages. Each argument may include aversion query suffixindicating the desired version, as ingo get golang.org/x/text@v0.3.0. A version query suffix consists of an@symbol followed by aversion query, which may indicate a specific version (v0.3.0), a version prefix (v0.3), a branch or tag name (master), a revision (1234abcd), or one of the special querieslatest,upgrade,patch, ornone. If no version is given,go getuses the@upgradequery. Oncego gethas resolved its arguments to specific modules and versions,go getwill add, change, or removerequiredirectivesin the main module’sgo.modfile to ensure the modules remain at the desired versions in the future. Note that required versions ingo.modfiles areminimum versionsand may be increased automatically as new dependencies are added. SeeMinimal version selection (MVS)for details on how versions are selected and conflicts are resolved by module-aware commands. Other modules may be upgraded when a module named on the command line is added, upgraded, or downgraded if the new version of the named module requires other modules at higher versions. For example, suppose moduleexample.com/ais upgraded to versionv1.5.0, and that version requires moduleexample.com/bat versionv1.2.0. If moduleexample.com/bis currently required at versionv1.1.0,go get example.com/a@v1.5.0will also upgradeexample.com/btov1.2.0. Other modules may be downgraded when a module named on the command line is downgraded or removed. To continue the above example, suppose moduleexample.com/bis downgraded tov1.1.0. Moduleexample.com/awould also be downgraded to a version that requiresexample.com/bat versionv1.1.0or lower. A module requirement may be removed using the version suffix@none. This is a special kind of downgrade. Modules that depend on the removed module will be downgraded or removed as needed. A module requirement may be removed even if one or more of its packages are imported by packages in the main module. In this case, the next build command may add a new module requirement. If a module is needed at two different versions (specified explicitly in command line arguments or to satisfy upgrades and downgrades),go getwill report an error. Aftergo gethas selected a new set of versions, it checks whether any newly selected module versions or any modules providing packages named on the command line areretractedordeprecated.go getprints a warning for each retracted version or deprecated module it finds.go list -m -u allmay be used to check for retractions and deprecations in all dependencies. Aftergo getupdates thego.modfile, it builds the packages named on the command line. Executables will be installed in the directory named by theGOBINenvironment variable, which defaults to$GOPATH/binor$HOME/go/binif theGOPATHenvironment variable is not set. go getsupports the following flags: Since Go 1.16,go installis the recommended command for building and installing programs. When used with a version suffix (like@latestor@v1.4.6),go installbuilds packages in module-aware mode, ignoring thego.modfile in the current directory or any parent directory, if there is one. go getis more focused on managing requirements ingo.mod. The-dflag is deprecated, and in Go 1.18, it will always be enabled. Usage: Examples: Thego installcommand builds and installs the packages named by the paths on the command line. Executables (mainpackages) are installed to the directory named by theGOBINenvironment variable, which defaults to$GOPATH/binor$HOME/go/binif theGOPATHenvironment variable is not set. Executables in$GOROOTare installed in$GOROOT/binor$GOTOOLDIRinstead of$GOBIN. Non-executable packages are built and cached but not installed. Since Go 1.16, if the arguments have version suffixes (like@latestor@v1.0.0),go installbuilds packages in module-aware mode, ignoring thego.modfile in the current directory or any parent directory if there is one. This is useful for installing executables without affecting the dependencies of the main module. To eliminate ambiguity about which module versions are used in the build, the arguments must satisfy the following constraints: SeeVersion queriesfor supported version query syntax. Go 1.15 and lower did not support using version queries withgo install. If the arguments don’t have version suffixes,go installmay run in module-aware mode orGOPATHmode, depending on theGO111MODULEenvironment variable and the presence of ago.modfile. SeeModule-aware commandsfor details. If module-aware mode is enabled,go installruns in the context of the main module, which may be different from the module containing the package being installed. Usage: Example: The-mflag causesgo listto list modules instead of packages. In this mode, the arguments togo listmay be modules, module patterns (containing the...wildcard),version queries, or the special patternall, which matches all modules in thebuild list. If no arguments are specified, themain moduleis listed. When listing modules, the-fflag still specifies a format template applied to a Go struct, but now aModulestruct: The default output is to print the module path and then information about the version and replacement if any. For example,go list -m allmight print: TheModulestruct has aStringmethod that formats this line of output, so that the default format is equivalent to-f '{{.String}}'. Note that when a module has been replaced, itsReplacefield describes the replacement module, and itsDirfield is set to the replacement module’s source code, if present. (That is, ifReplaceis non-nil, thenDiris set toReplace.Dir, with no access to the replaced source code.) The-uflag adds information about available upgrades. When the latest version of a given module is newer than the current one,list -usets the module’sUpdatefield to information about the newer module.list -ualso prints whether the currently selected version isretractedand whether the module isdeprecated. The module’sStringmethod indicates an available upgrade by formatting the newer version in brackets after the current version. For example,go list -m -u allmight print: (For tools,go list -m -u -json allmay be more convenient to parse.) The-versionsflag causeslistto set the module’sVersionsfield to a list of all known versions of that module, ordered according to semantic versioning, lowest to highest. The flag also changes the default output format to display the module path followed by the space-separated version list. Retracted versions are omitted from this list unless the-retractedflag is also specified. The-retractedflag instructslistto show retracted versions in the list printed with the-versionsflag and to consider retracted versions when resolvingversion queries. For example,go list -m -retracted example.com/m@latestshows the highest release or pre-release version of the moduleexample.com/m, even if that version is retracted.retractdirectivesanddeprecationsare loaded from thego.modfile at this version. The-retractedflag was added in Go 1.16. The template functionmoduletakes a single string argument that must be a module path or query and returns the specified module as aModulestruct. If an error occurs, the result will be aModulestruct with a non-nilErrorfield. Usage: Example: Thego mod downloadcommand downloads the named modules into themodule cache. Arguments can be module paths or module patterns selecting dependencies of the main module orversion queriesof the formpath@version. With no arguments,downloadapplies to all dependencies of themain module. Thegocommand will automatically download modules as needed during ordinary execution. Thego mod downloadcommand is useful mainly for pre-filling the module cache or for loading data to be served by amodule proxy. By default,downloadwrites nothing to standard output. It prints progress messages and errors to standard error. The-jsonflag causesdownloadto print a sequence of JSON objects to standard output, describing each downloaded module (or failure), corresponding to this Go struct: The-xflag causesdownloadto print the commandsdownloadexecutes to standard error. The -reuse flag accepts the name of file containing the JSON output of a previous ‘go mod download -json’ invocation. The go command may use this file to determine that a module is unchanged since the previous invocation and avoid redownloading it. Modules that are not redownloaded will be marked in the new output by setting the Reuse field to true. Normally the module cache provides this kind of reuse automatically; the -reuse flag can be useful on systems that do not preserve the module cache. Usage: Example: Thego mod editcommand provides a command-line interface for editing and formattinggo.modfiles, for use primarily by tools and scripts.go mod editreads only onego.modfile; it does not look up information about other modules. By default,go mod editreads and writes thego.modfile of the main module, but a different target file can be specified after the editing flags. The editing flags specify a sequence of editing operations. The editing flags may be repeated. The changes are applied in the order given. go mod edithas additional flags that control its output. Note that this only describes thego.modfile itself, not other modules referred to indirectly. For the full set of modules available to a build, usego list -m -json all. Seego list -m. For example, a tool can obtain thego.modfile as a data structure by parsing the output ofgo mod edit -jsonand can then make changes by invokinggo mod editwith-require,-exclude, and so on. Tools may also use the packagegolang.org/x/mod/modfileto parse, edit, and formatgo.modfiles. Usage: Thego mod graphcommand prints themodule requirement graph(with replacements applied) in text form. For example: Each vertex in the module graph represents a specific version of a module. Each edge in the graph represents a requirement on a minimum version of a dependency. go mod graphprints the edges of the graph, one per line. Each line has two space-separated fields: a module version and one of its dependencies. Each module version is identified as a string of the formpath@version. The main module has no@versionsuffix, since it has no version. The-goflag causesgo mod graphto report the module graph as loaded by the given Go version, instead of the version indicated by thegodirectivein thego.modfile. SeeMinimal version selection (MVS)for more information on how versions are chosen. See alsogo list -mfor printing selected versions andgo mod whyfor understanding why a module is needed. Usage: Example: Thego mod initcommand initializes and writes a newgo.modfile in the current directory, in effect creating a new module rooted at the current directory. Thego.modfile must not already exist. initaccepts one optional argument, themodule pathfor the new module. SeeModule pathsfor instructions on choosing a module path. If the module path argument is omitted,initwill attempt to infer the module path using import comments in.gofiles, vendoring tool configuration files, and the current directory (if inGOPATH). If a configuration file for a vendoring tool is present,initwill attempt to import module requirements from it.initsupports the following configuration files. Vendoring tool configuration files can’t always be translated with perfect fidelity. For example, if multiple packages within the same repository are imported at different versions, and the repository only contains one module, the importedgo.modcan only require the module at one version. You may wish to rungo list -m allto check all versions in thebuild list, andgo mod tidyto add missing requirements and to drop unused requirements. Usage: go mod tidyensures that thego.modfile matches the source code in the module. It adds any missing module requirements necessary to build the current module’s packages and dependencies, and it removes requirements on modules that don’t provide any relevant packages. It also adds any missing entries togo.sumand removes unnecessary entries. The-eflag (added in Go 1.16) causesgo mod tidyto attempt to proceed despite errors encountered while loading packages. The-vflag causesgo mod tidyto print information about removed modules to standard error. The-xflag causesgo mod tidyto print the commandstidyexecutes. The-diffflag causesgo mod tidynot to modify go.mod or go.sum but instead print the necessary changes as a unified diff. It exits with a non-zero code if the diff is not empty. go mod tidyworks by loading all of the packages in themain module, all of its tools, and all of the packages they import, recursively. This includes packages imported by tests (including tests in other modules).go mod tidyacts as if all build tags are enabled, so it will consider platform-specific source files and files that require custom build tags, even if those source files wouldn’t normally be built. There is one exception: theignorebuild tag is not enabled, so a file with the build constraint// +build ignorewill not be considered. Note thatgo mod tidywill not consider packages in the main module in directories namedtestdataor with names that start with.orunless those packages are explicitly imported by other packages. Oncego mod tidyhas loaded this set of packages, it ensures that each module that provides one or more packages has arequiredirective in the main module’sgo.modfile or — if the main module is atgo 1.16or below — is required by another required module.go mod tidywill add a requirement on the latest version of each missing module (seeVersion queriesfor the definition of thelatestversion).go mod tidywill removerequiredirectives for modules that don’t provide any packages in the set described above. go mod tidymay also add or remove// indirectcomments onrequiredirectives. An// indirectcomment denotes a module that does not provide a package imported by a package in the main module. (See therequiredirectivefor more detail on when// indirectdependencies and comments are added.) If the-goflag is set,go mod tidywill update thegodirectiveto the indicated version, enabling or disablingmodule graph pruningandlazy module loading(and adding or removing indirect requirements as needed) according to that version. By default,go mod tidywill check that theselected versionsof modules do not change when the module graph is loaded by the Go version immediately preceding the version indicated in thegodirective. The versioned checked for compatibility can also be specified explicitly via the-compatflag. Usage: Thego mod vendorcommand constructs a directory namedvendorin themain module’sroot directory that contains copies of all packages needed to support builds and tests of packages in the main module. Packages that are only imported by tests of packages outside the main module are not included. As withgo mod tidyand other module commands,build constraintsexcept forignoreare not considered when constructing thevendordirectory. When vendoring is enabled, thegocommand will load packages from thevendordirectory instead of downloading modules from their sources into the module cache and using packages those downloaded copies. SeeVendoringfor more information. go mod vendoralso creates the filevendor/modules.txtthat contains a list of vendored packages and the module versions they were copied from. When vendoring is enabled, this manifest is used as a source of module version information, as reported bygo list -mandgo version -m. When thegocommand readsvendor/modules.txt, it checks that the module versions are consistent withgo.mod. Ifgo.modchanged sincevendor/modules.txtwas generated,go mod vendorshould be run again. Note thatgo mod vendorremoves thevendordirectory if it exists before re-constructing it. Local changes should not be made to vendored packages. Thegocommand does not check that packages in thevendordirectory have not been modified, but one can verify the integrity of thevendordirectory by runninggo mod vendorand checking that no changes were made. The-eflag (added in Go 1.16) causesgo mod vendorto attempt to proceed despite errors encountered while loading packages. The-vflag causesgo mod vendorto print the names of vendored modules and packages to standard error. The-oflag (added in Go 1.18) causesgo mod vendorto output the vendor tree at the specified directory instead ofvendor. The argument can be either an absolute path or a path relative to the module root. Usage: go mod verifychecks that dependencies of themain modulestored in themodule cachehave not been modified since they were downloaded. To perform this check,go mod verifyhashes each downloaded module.zipfileand extracted directory, then compares those hashes with a hash recorded when the module was first downloaded.go mod verifychecks each module in thebuild list(which may be printed withgo list -m all). If all the modules are unmodified,go mod verifyprints “all modules verified”. Otherwise, it reports which modules have been changed and exits with a non-zero status. Note that all module-aware commands verify that hashes in the main module’sgo.sumfile match hashes recorded for modules downloaded into the module cache. If a hash is missing fromgo.sum(for example, because the module is being used for the first time), thegocommand verifies its hash using thechecksum database(unless the module path is matched byGOPRIVATEorGONOSUMDB). SeeAuthenticating modulesfor details. In contrast,go mod verifychecks that module.zipfiles and their extracted directories have hashes that match hashes recorded in the module cache when they were first downloaded. This is useful for detecting changes to files in the module cacheaftera module has been downloaded and verified.go mod verifydoes not download content for modules not in the cache, and it does not usego.sumfiles to verify module content. However,go mod verifymay downloadgo.modfiles in order to performminimal version selection. It will usego.sumto verify those files, and it may addgo.sumentries for missing hashes. Usage: go mod whyshows a shortest path in the import graph from the main module to each of the listed packages. The output is a sequence of stanzas, one for each package or module named on the command line, separated by blank lines. Each stanza begins with a comment line starting with#giving the target package or module. Subsequent lines give a path through the import graph, one package per line. If the package or module is not referenced from the main module, the stanza will display a single parenthesized note indicating that fact. For example: The-mflag causesgo mod whyto treat its arguments as a list of modules.go mod whywill print a path to any package in each of the modules. Note that even when-mis used,go mod whyqueries the package graph, not the module graph printed bygo mod graph. The-vendorflag causesgo mod whyto ignore imports in tests of packages outside the main module (asgo mod vendordoes). By default,go mod whyconsiders the graph of packages matched by theallpattern. This flag has no effect after Go 1.16 in modules that declarego 1.16or higher (using thegodirectiveingo.mod), since the meaning ofallchanged to match the set of packages matched bygo mod vendor. Usage: Example: go versionreports the Go version used to build each executable file named on the command line. If no files are named on the command line,go versionprints its own version information. If a directory is named,go versionwalks that directory, recursively, looking for recognized Go binaries and reporting their versions. By default,go versiondoes not report unrecognized files found during a directory scan. The-vflag causes it to report unrecognized files. The-mflag causesgo versionto print each executable’s embedded module version information, when available. For each executable,go version -mprints a table with tab-separated columns like the one below. The format of the table may change in the future. The same information may be obtained fromruntime/debug.ReadBuildInfo. The meaning of each row in the table is determined by the word in the first column. Usage: The-modcacheflag causesgo cleanto remove the entiremodule cache, including unpacked source code of versioned dependencies. This is usually the best way to remove the module cache. By default, most files and directories in the module cache are read-only to prevent tests and editors from unintentionally changing files after they’ve beenauthenticated. Unfortunately, this causes commands likerm -rto fail, since files can’t be removed without first making their parent directories writable. The-modcacherwflag (accepted bygo buildand other module-aware commands) causes new directories in the module cache to be writable. To pass-modcacherwto all module-aware commands, add it to theGOFLAGSvariable.GOFLAGSmay be set in the environment or withgo env -w. For example, the command below sets it permanently: -modcacherwshould be used with caution; developers should be careful not to make changes to files in the module cache.go mod verifymay be used to check that files in the cache match hashes in the main module’sgo.sumfile. Several commands allow you to specify a version of a module using aversion query, which appears after an@character following a module or package path on the command line. Examples: A version query may be one of the following: Except for queries for specific named versions or revisions, all queries consider available versions reported bygo list -m -versions(seego list -m). This list contains only tagged versions, not pseudo-versions. Module versions disallowed byexcludedirectivesin the main module’sgo.modfileare not considered. Versions covered byretractdirectivesin thego.modfile from thelatestversion of the same module are also ignored except when the-retractedflag is used withgo list -mand except when loadingretractdirectives. Release versionsare preferred over pre-release versions. For example, if versionsv1.2.2andv1.2.3-preare available, thelatestquery will selectv1.2.2, even thoughv1.2.3-preis higher. Thetag with the namego-importin the HTML response. The tag’s content must contain therepository root path, the version control system, and the URL, separated by spaces. SeeFinding a repository for a module pathfor details. If the version control system ismod, thegocommand downloads the module from the given URL using theGOPROXYprotocol. For example, suppose thegocommand is attempting to download the moduleexample.com/gopherat versionv1.0.0. It sends a request tohttps://example.com/gopher?go-get=1. The server responds with an HTML document containing the tag: Based on this response, thegocommand downloads the module by sending requests forhttps://modproxy.example.com/example.com/gopher/@v/v1.0.0.info,v1.0.0.mod, andv1.0.0.zip. Note that modules served directly from a proxy cannot be downloaded withgo getin GOPATH mode. Thegocommand may download module source code and metadata directly from a version control repository. Downloading a module from aproxyis usually faster, but connecting directly to a repository is necessary if a proxy is not available or if a module’s repository is not accessible to a proxy (frequently true for private repositories). Git, Subversion, Mercurial, Bazaar, and Fossil are supported. A version control tool must be installed in a directory inPATHin order for thegocommand to use it. To download specific modules from source repositories instead of a proxy, set theGOPRIVATEorGONOPROXYenvironment variables. To configure thegocommand to download all modules directly from source repositories, setGOPROXYtodirect. SeeEnvironment variablesfor more information. When thegocommand downloads a module indirectmode, it starts by locating the repository that contains the module. If the module path has a VCS qualifier (one of.bzr,.fossil,.git,.hg,.svn) at the end of a path component, thegocommand will use everything up to that path qualifier as the repository URL. For example, for the moduleexample.com/foo.git/bar, thegocommand downloads the repository atexample.com/foousing git, expecting to find the module in thebarsubdirectory. Thegocommand will guess the protocol to use based on the protocols supported by the version control tool. If the module path does not have a qualifier, thegocommand sends an HTTPGETrequest to a URL derived from the module path with a?go-get=1query string. For example, for the modulegolang.org/x/mod, thegocommand may send the following requests: Thegocommand follows redirects but otherwise ignores response status codes, so the server may respond with a 404 or any other error status. TheGOINSECUREenvironment variable may be set to allow fallback and redirects to unencrypted HTTP for specific modules. The server must respond with an HTML document containing atag in the document’s. Thetag should appear early in the document to avoid confusing thegocommand’s restricted parser. In particular, it should appear before any raw JavaScript or CSS. Thetag must have the form: root-pathis the repository root path, the portion of the module path that corresponds to the repository’s root directory. It must be a prefix or an exact match of the requested module path. If it’s not an exact match, another request is made for the prefix to verify thetags match. vcsis the version control system. It must be one of the tools listed in the table below or the keywordmod, which instructs thegocommand to download the module from the given URL using theGOPROXYprotocol. SeeServing modules directly from a proxyfor details. repo-urlis the repository’s URL. If the URL does not include a scheme (either because the module path has a VCS qualifier or because thetag lacks a scheme), thegocommand will try each protocol supported by the version control system. For example, with Git, thegocommand will tryhttps://thengit+ssh://. Insecure protocols (likehttp://andgit://) may only be used if the module path is matched by theGOINSECUREenvironment variable. As an example, considergolang.org/x/modagain. Thegocommand sends a request tohttps://golang.org/x/mod?go-get=1. The server responds with an HTML document containing the tag: From this response, thegocommand will use the Git repository at the remote URLhttps://go.googlesource.com/mod. GitHub and other popular hosting services respond to?go-get=1queries for all repositories, so usually no server configuration is necessary for modules hosted at those sites. After the repository URL is found, thegocommand will clone the repository into the module cache. In general, thegocommand tries to avoid fetching unneeded data from a repository. However, the actual commands used vary by version control system and may change over time. For Git, thegocommand can list most available versions without downloading commits. It will usually fetch commits without downloading ancestor commits, but doing so is sometimes necessary. Thegocommand may check out a module within a repository at a specificcanonical versionlikev1.2.3,v2.4.0-beta, orv3.0.0+incompatible. Each module version should have asemantic version tagwithin the repository that indicates which revision should be checked out for a given version. If a module is defined in the repository root directory or in a major version subdirectory of the root directory, then each version tag name is equal to the corresponding version. For example, the modulegolang.org/x/textis defined in the root directory of its repository, so the versionv0.3.2has the tagv0.3.2in that repository. This is true for most modules. If a module is defined in a subdirectory within the repository, that is, themodule subdirectoryportion of the module path is not empty, then each tag name must be prefixed with the module subdirectory, followed by a slash. For example, the modulegolang.org/x/tools/goplsis defined in thegoplssubdirectory of the repository with root pathgolang.org/x/tools. The versionv0.4.0of that module must have the tag namedgopls/v0.4.0in that repository. The major version number of a semantic version tag must be consistent with the module path’s major version suffix (if any). For example, the tagv1.0.0could belong to the moduleexample.com/modbut notexample.com/mod/v2, which would have tags likev2.0.0. A tag with major versionv2or higher may belong to a module without a major version suffix if nogo.modfile is present, and the module is in the repository root directory. This kind of version is denoted with the suffix+incompatible. The version tag itself must not have the suffix. SeeCompatibility with non-module repositories. Once a tag is created, it should not be deleted or changed to a different revision. Versions areauthenticatedto ensure safe, repeatable builds. If a tag is modified, clients may see a security error when downloading it. Even after a tag is deleted, its content may remain available onmodule proxies. Thegocommand may check out a module within a repository at a specific revision, encoded as apseudo-versionlikev1.3.2-0.20191109021931-daa7c04131f5. The last 12 characters of the pseudo-version (daa7c04131f5in the example above) indicate a revision in the repository to check out. The meaning of this depends on the version control system. For Git and Mercurial, this is a prefix of a commit hash. For Subversion, this is a zero-padded revision number. Before checking out a commit, thegocommand verifies that the timestamp (20191109021931above) matches the commit date. It also verifies that the base version (v1.3.1, the version beforev1.3.2in the example above) corresponds to a semantic version tag that is an ancestor of the commit. These checks ensure that module authors have full control over how pseudo-versions compare with other released versions. SeePseudo-versionsfor more information. A module may be checked out at a specific branch, tag, or revision using aversion query. Thegocommand converts these names intocanonical versionsthat can be used withminimal version selection (MVS). MVS depends on the ability to order versions unambiguously. Branch names and revisions can’t be compared reliably over time, since they depend on repository structure which may change. If a revision is tagged with one or more semantic version tags likev1.2.3, the tag for the highest valid version will be used. Thegocommand only considers semantic version tags that could belong to the target module; for example, the tagv1.5.2would not be considered forexample.com/mod/v2since the major version doesn’t match the module path’s suffix. If a revision is not tagged with a valid semantic version tag, thegocommand will generate apseudo-version. If the revision has ancestors with valid semantic version tags, the highest ancestor version will be used as the pseudo-version base. SeePseudo-versions. Once a module’s repository has been checked out at a specific revision, thegocommand must locate the directory that contains the module’sgo.modfile (the module’s root directory). Recall that amodule pathconsists of three parts: a repository root path (corresponding to the repository root directory), a module subdirectory, and a major version suffix (only for modules released atv2or higher). For most modules, the module path is equal to the repository root path, so the module’s root directory is the repository’s root directory. Modules are sometimes defined in repository subdirectories. This is typically done for large repositories with multiple components that need to be released and versioned independently. Such a module is expected to be found in a subdirectory that matches the part of the module’s path after the repository root path. For example, suppose the moduleexample.com/monorepo/foo/baris in the repository with root pathexample.com/monorepo. Itsgo.modfile must be in thefoo/barsubdirectory. If a module is released at major versionv2or higher, its path must have amajor version suffix. A module with a major version suffix may be defined in one of two subdirectories: one with the suffix, and one without. For example, suppose a new version of the module above is released with the pathexample.com/monorepo/foo/bar/v2. Itsgo.modfile may be in eitherfoo/barorfoo/bar/v2. Subdirectories with a major version suffix aremajor version subdirectories. They may be used to develop multiple major versions of a module on a single branch. This may be unnecessary when development of multiple major versions proceeds on separate branches. However, major version subdirectories have an important property: inGOPATHmode, package import paths exactly match directories underGOPATH/src. Thegocommand provides minimal module compatibility inGOPATHmode (seeCompatibility with non-module repositories), so major version subdirectories aren’t always necessary for compatibility with projects built inGOPATHmode. Older tools that don’t support minimal module compatibility may have problems though. Once thegocommand has found the module root directory, it creates a.zipfile of the contents of the directory, then extracts the.zipfile into the module cache. SeeFile path and size constraintsfor details on what files may be included in the.zipfile. The contents of the.zipfile areauthenticatedbefore extraction into the module cache the same way they would be if the.zipfile were downloaded from a proxy. Module zip files do not include the contents ofvendordirectories or any nested modules (subdirectories that containgo.modfiles). This means a module must take care not to refer to files outside its directory or in other modules. For example,//go:embedpatterns must not match files in nested modules. This behavior may serve as a useful workaround in situations where files should not be included in a module. For example, if a repository has large files checked into atestdatadirectory, the module author could add an emptygo.modfile intestdataso their users don’t need to download those files. Of course, this may reduce coverage for users testing their dependencies. When thegocommand creates a.zipfile for a module that is not in the repository root directory, if the module does not have a file namedLICENSEin its root directory (alongsidego.mod), thegocommand will copy the file namedLICENSEfrom the repository root directory if it is present in the same revision. This special case allows the sameLICENSEfile to apply to all modules within a repository. This only applies to files namedLICENSEspecifically, without extensions like.txt. Unfortunately, this cannot be extended without breaking cryptographic sums of existing modules; seeAuthenticating modules. Other tools and websites likepkg.go.devmay recognize files with other names. Note also that thegocommand does not include symbolic links when creating module.zipfiles; seeFile path and size constraints. Consequently, if a repository does not have aLICENSEfile in its root directory, authors may instead create copies of their license files in modules defined in subdirectories to ensure those files are included in module.zipfiles. Thegocommand’s ability to download modules with version control commands likegitis critical to the decentralized package ecosystem, in which code can be imported from any server. It is also a potential security problem if a malicious server finds a way to cause the invoked version control command to run unintended code. To balance the functionality and security concerns, thegocommand by default will only usegitandhgto download code from public servers. It will use anyknown version control systemto download code from private servers, defined as those hosting packages matching theGOPRIVATEenvironment variable. The rationale behind allowing only Git and Mercurial is that these two systems have had the most attention to issues of being run as clients of untrusted servers. In contrast, Bazaar, Fossil, and Subversion have primarily been used in trusted, authenticated environments and are not as well scrutinized as attack surfaces. The version control command restrictions only apply when using direct version control access to download code. When downloading modules from a proxy, thegocommand uses theGOPROXYprotocolinstead, which is always permitted. By default, thegocommand uses the Go module mirror (proxy.golang.org) for public modules and only falls back to version control for private modules or when the mirror refuses to serve a public package (typically for legal reasons). Therefore, clients can still access public code served from Bazaar, Fossil, or Subversion repositories by default, because those downloads use the Go module mirror, which takes on the security risk of running the version control commands using a custom sandbox. TheGOVCSvariable can be used to change the allowed version control systems for specific modules. TheGOVCSvariable applies when building packages in both module-aware mode and GOPATH mode. When using modules, the patterns match against the module path. When using GOPATH, the patterns match against the import path corresponding to the root of the version control repository. The general form of theGOVCSvariable is a comma-separated list ofpattern:vcslistrules. The pattern is aglob patternthat must match one or more leading elements of the module or import path. The vcslist is a pipe-separated list of allowed version control commands, orallto allow use of any known command, oroffto allow nothing. Note that if a module matches a pattern with vcslistoff, it may still be downloaded if the origin server uses themodscheme, which instructs the go command to download the module using theGOPROXYprotocol. The earliest matching pattern in the list applies, even if later patterns might also match. For example, consider: With this setting, code with a module or import path beginning withgithub.com/can only usegit; paths onevil.comcannot use any version control command, and all other paths (matches everything) can use onlygitorhg. The special patternspublicandprivatematch public and private module or import paths. A path is private if it matches theGOPRIVATEvariable; otherwise it is public. If no rules in theGOVCSvariable match a particular module or import path, thegocommand applies its default rule, which can now be summarized inGOVCSnotation aspublic:git|hg,private:all. To allow unfettered use of any version control system for any package, use: To disable all use of version control, use: Thego env -wcommandcan be used to set theGOVCSvariable for future go command invocations. GOVCSwas introduced in Go 1.16. Earlier versions of Go may use any known version control tool for any module. Module versions are distributed as.zipfiles. There is rarely any need to interact directly with these files, since thegocommand creates, downloads, and extracts them automatically frommodule proxiesand version control repositories. However, it’s still useful to know about these files to understand cross-platform compatibility constraints or when implementing a module proxy. Thego mod downloadcommand downloads zip files for one or more modules, then extracts those files into themodule cache. Depending onGOPROXYand otherenvironment variables, thegocommand may either download zip files from a proxy or clone source control repositories and create zip files from them. The-jsonflag may be used to find the location of download zip files and their extracted contents in the module cache. Thegolang.org/x/mod/zippackage may be used to create, extract, or check contents of zip files programmatically. There are a number of restrictions on the content of module zip files. These constraints ensure that zip files can be extracted safely and consistently on a wide range of platforms. Go modules are frequently developed and distributed on version control servers and module proxies that aren’t available on the public internet. Thegocommand can download and build modules from private sources, though it usually requires some configuration. The environment variables below may be used to configure access to private modules. SeeEnvironment variablesfor details. See alsoPrivacyfor information on controlling information sent to public servers. These variables may be set in the development environment (for example, in a.profilefile), or they may be set permanently withgo env -w. The rest of this section describes common patterns for providing access to private module proxies and version control repositories. A central private proxy server that serves all modules (public and private) provides the most control for administrators and requires the least configuration for individual developers. To configure thegocommand to use such a server, set the following environment variables, replacinghttps://proxy.corp.example.comwith your proxy URL andcorp.example.comwith your module prefix: TheGOPROXYsetting instructs thegocommand to only download modules fromhttps://proxy.corp.example.com; thegocommand will not connect to other proxies or version control repositories. TheGONOSUMDBsetting instructs thegocommand not to use the public checksum database to authenticate modules with paths starting withcorp.example.com. A proxy running in this configuration will likely need read access to private version control servers. It will also need access to the public internet to download new versions of public modules. There are several existing implementations ofGOPROXYservers that may be used this way. A minimal implementation would serve files from amodule cachedirectory and would usego mod download(with suitable configuration) to retrieve missing modules. A private proxy server may serve private modules without also serving publicly available modules. Thegocommand can be configured to fall back to public sources for modules that aren’t available on the private server. To configure thegocommand to work this way, set the following environment variables, replacinghttps://proxy.corp.example.comwith the proxy URL andcorp.example.comwith the module prefix: TheGOPROXYsetting instructs thegocommand to try to download modules fromhttps://proxy.corp.example.comfirst. If that server responds with 404 (Not Found) or 410 (Gone), thegocommand will fall back tohttps://proxy.golang.org, then to direct connections to repositories. TheGONOSUMDBsetting instructs thegocommand not to use the public checksum database to authenticate modules whose paths start withcorp.example.com. Note that a proxy used in this configuration may still control access to public modules, even though it doesn’t serve them. If the proxy responds to a request with an error status other than 404 or 410, thegocommand will not fall back to later entries in theGOPROXYlist. For example, the proxy could respond with 403 (Forbidden) for a module with an unsuitable license or with known security vulnerabilities. Thegocommand may be configured to bypass public proxies and download private modules directly from version control servers. This is useful when running a private proxy server is not feasible. To configure thegocommand to work this way, setGOPRIVATE, replacingcorp.example.comthe private module prefix: TheGOPROXYvariable does not need to be changed in this situation. It defaults tohttps://proxy.golang.org,direct, which instructs thegocommand to attempt to download modules fromhttps://proxy.golang.orgfirst, then fall back to a direct connection if that proxy responds with 404 (Not Found) or 410 (Gone). TheGOPRIVATEsetting instructs thegocommand not to connect to a proxy or to the checksum database for modules starting withcorp.example.com. An internal HTTP server may still be needed toresolve module paths to repository URLs. For example, when thegocommand downloads the modulecorp.example.com/mod, it will send a GET request tohttps://corp.example.com/mod?go-get=1, and it will look for the repository URL in the response. To avoid this requirement, ensure that each private module path has a VCS suffix (like.git) marking the repository root prefix. For example, when thegocommand downloads the modulecorp.example.com/repo.git/mod, it will clone the Git repository athttps://corp.example.com/repo.gitorssh://corp.example.com/repo.gitwithout needing to make additional requests. Developers will need read access to repositories containing private modules. This may be configured in global VCS configuration files like.gitconfig. It’s best if VCS tools are configured not to need interactive authentication prompts. By default, when invoking Git, thegocommand disables interactive prompts by settingGITTERMINALPROMPT=0, but it respects explicit settings. Thegocommand supports HTTPbasic authenticationwhen communicating with proxy servers. Credentials may be specified in a.netrcfile. For example, a.netrcfile containing the lines below would configure thegocommand to connect to the machineproxy.corp.example.comwith the given username and password. The location of the file may be set with theNETRCenvironment variable. IfNETRCis not set, thegocommand will read$HOME/.netrcon UNIX-like platforms or%USERPROFILE%\netrcon Windows. Fields in.netrcare separated with spaces, tabs, and newlines. Unfortunately, these characters cannot be used in usernames or passwords. Note also that the machine name cannot be a full URL, so it’s not possible to specify different usernames and passwords for different paths on the same machine. Alternatively, credentials may be specified directly inGOPROXYURLs. For example: Use caution when taking this approach: environment variables may appear in shell history and in logs. Thegocommand may download a module directly from a version control repository. This is necessary for private modules if a private proxy is not used. SeeDirect access to private modulesfor configuration. Thegocommand runs version control tools likegitwhen downloading modules directly. These tools perform their own authentication, so you may need to configure credentials in a tool-specific configuration file like.gitconfig. To ensure this works smoothly, make sure thegocommand uses the correct repository URL and that the version control tool doesn’t require a password to be entered interactively. Thegocommand prefershttps://URLs over other schemes likessh://unless the scheme was specified whenlooking up the repository URL. For GitHub repositories specifically, thegocommand assumeshttps://. For most servers, you can configure your client to authenticate over HTTP. For example, GitHub supports usingOAuth personal access tokens as HTTP passwords. You can store HTTP passwords in a.netrcfile, as whenpassing credentials to private proxies. Alternatively, you can rewritehttps://URLs to another scheme. For example, in.gitconfig: For more information, seeWhy does “go get” use HTTPS when cloning a repository? Thegocommand may download modules and metadata from module proxy servers and version control systems. The environment variableGOPROXYcontrols which servers are used. The environment variablesGOPRIVATEandGONOPROXYcontrol which modules are fetched from proxies. The default value ofGOPROXYis: With this setting, when thegocommand downloads a module or module metadata, it will first send a request toproxy.golang.org, a public module proxy operated by Google (privacy policy). SeeGOPROXYprotocolfor details on what information is sent in each request. Thegocommand does not transmit personally identifiable information, but it does transmit the full module path being requested. If the proxy responds with a 404 (Not Found) or 410 (Gone) status, thegocommand will attempt to connect directly to the version control system providing the module. SeeVersion control systemsfor details. TheGOPRIVATEorGONOPROXYenvironment variables may be set to lists of glob patterns matching module prefixes that are private and should not be requested from any proxy. For example: GOPRIVATEsimply acts as a default forGONOPROXYandGONOSUMDB, so it’s not necessary to setGONOPROXYunlessGONOSUMDBshould have a different value. When a module path is matched byGONOPROXY, thegocommand ignoresGOPROXYfor that module and fetches it directly from its version control repository. This is useful when no proxy serves private modules. SeeDirect access to private modules. If there is atrusted proxy serving all modules, thenGONOPROXYshould not be set. For example, ifGOPROXYis set to one source, thegocommand will not download modules from other sources.GONOSUMDBshould still be set in this situation. If there is atrusted proxy serving only private modules,GONOPROXYshould not be set, but care must be taken to ensure the proxy responds with the correct status codes. For example, consider the following configuration: Suppose that due to a typo, a developer attempts to download a module that doesn’t exist. Thegocommand first requests this module fromproxy.corp.example.com. If that proxy responds with 404 (Not Found) or 410 (Gone), thegocommand will fall back toproxy.golang.org, transmitting thesecret-productpath in the request URL. If the private proxy responds with any other error code, thegocommand prints the error and will not fall back to other sources. In addition to proxies, thegocommand may connect to the checksum database to verify cryptographic hashes of modules not listed ingo.sum. TheGOSUMDBenvironment variable sets the name, URL, and public key of the checksum database. The default value ofGOSUMDBissum.golang.org, the public checksum database operated by Google (privacy policy). SeeChecksum databasefor details on what is transmitted with each request. As with proxies, thegocommand does not transmit personally identifiable information, but it does transmit the full module path being requested, and the checksum database cannot compute checksums for non-public modules. TheGONOSUMDBenvironment variable may be set to patterns indicating which modules are private and should not be requested from the checksum database.GOPRIVATEacts as a default forGONOSUMDBandGONOPROXY, so it’s not necessary to setGONOSUMDBunlessGONOPROXYshould have a different value. A proxy maymirror the checksum database. If a proxy inGOPROXYdoes this, thegocommand will not connect to the checksum database directly. GOSUMDBmay be set tooffto disable use of the checksum database entirely. With this setting, thegocommand will not authenticate downloaded modules unless they’re already ingo.sum. SeeAuthenticating modules. Themodule cacheis the directory where thegocommand stores downloaded module files. The module cache is distinct from the build cache, which contains compiled packages and other build artifacts. The default location of the module cache is$GOPATH/pkg/mod. To use a different location, set theGOMODCACHEenvironment variable. The module cache has no maximum size, and thegocommand does not remove its contents automatically. The cache may be shared by multiple Go projects developed on the same machine. Thegocommand will use the same cache regardless of the location of the main module. Multiple instances of thegocommand may safely access the same module cache at the same time. Thegocommand creates module source files and directories in the cache with read-only permissions to prevent accidental changes to modules after they’re downloaded. This has the unfortunate side-effect of making the cache difficult to delete with commands likerm -rf. The cache may instead be deleted withgo clean -modcache. Alternatively, when the-modcacherwflag is used, thegocommand will create new directories with read-write permissions. This increases the risk of editors, tests, and other programs modifying files in the module cache. Thego mod verifycommand may be used to detect modifications to dependencies of the main module. It scans the extracted contents of each module dependency and confirms they match the expected hash ingo.sum. The table below explains the purpose of most files in the module cache. Some transient files (lock files, temporary directories) are omitted. For each path,$moduleis a module path, and$versionis a version. Paths ending with slashes (/) are directories. Capital letters in module paths and versions are escaped using exclamation points (Azureis escaped as!azure) to avoid conflicts on case-insensitive file systems. When thegocommand downloads a modulezip fileorgo.modfileinto themodule cache, it computes a cryptographic hash and compares it with a known value to verify the file hasn’t changed since it was first downloaded. Thegocommand reports a security error if a downloaded file does not have the correct hash. Forgo.modfiles, thegocommand computes the hash from the file content. For module zip files, thegocommand computes the hash from the names and contents of files within the archive in a deterministic order. The hash is not affected by file order, compression, alignment, and other metadata. Seegolang.org/x/mod/sumdb/dirhashfor hash implementation details. Thegocommand compares each hash with the corresponding line in the main module’sgo.sumfile. If the hash is different from the hash ingo.sum, thegocommand reports a security error and deletes the downloaded file without adding it into the module cache. If thego.sumfile is not present, or if it doesn’t contain a hash for the downloaded file, thegocommand may verify the hash using thechecksum database, a global source of hashes for publicly available modules. Once the hash is verified, thegocommand adds it togo.sumand adds the downloaded file in the module cache. If a module is private (matched by theGOPRIVATEorGONOSUMDBenvironment variables) or if the checksum database is disabled (by settingGOSUMDB=off), thegocommand accepts the hash and adds the file to the module cache without verifying it. The module cache is usually shared by all Go projects on a system, and each module may have its owngo.sumfile with potentially different hashes. To avoid the need to trust other modules, thegocommand verifies hashes using the main module’sgo.sumwhenever it accesses a file in the module cache. Zip file hashes are expensive to compute, so thegocommand checks pre-computed hashes stored alongside zip files instead of re-hashing the files. Thego mod verifycommand may be used to check that zip files and extracted directories have not been modified since they were added to the module cache. A module may have a text file namedgo.sumin its root directory, alongside itsgo.modfile. Thego.sumfile contains cryptographic hashes of the module’s direct and indirect dependencies. When thegocommand downloads a module.modor.zipfile into themodule cache, it computes a hash and checks that the hash matches the corresponding hash in the main module’sgo.sumfile.go.summay be empty or absent if the module has no dependencies or if all dependencies are replaced with local directories usingreplacedirectives. Each line ingo.sumhas three fields separated by spaces: a module path, a version (possibly ending with/go.mod), and a hash. Thego.sumfile may contain hashes for multiple versions of a module. Thegocommand may need to loadgo.modfiles from multiple versions of a dependency in order to performminimal version selection.go.summay also contain hashes for module versions that aren’t needed anymore (for example, after an upgrade).go mod tidywill add missing hashes and will remove unnecessary hashes fromgo.sum. The checksum database is a global source ofgo.sumlines. Thegocommand can use this in many situations to detect misbehavior by proxies or origin servers. The checksum database allows for global consistency and reliability for all publicly available module versions. It makes untrusted proxies possible since they can’t serve the wrong code without it going unnoticed. It also ensures that the bits associated with a specific version do not change from one day to the next, even if the module’s author subsequently alters the tags in their repository. The checksum database is served bysum.golang.org, which is run by Google. It is aTransparent Log(or “Merkle Tree”) ofgo.sumline hashes, which is backed byTrillian. The main advantage of a Merkle tree is that independent auditors can verify that it hasn’t been tampered with, so it is more trustworthy than a simple database. Thegocommand interacts with the checksum database using the protocol originally outlined inProposal: Secure the Public Go Module Ecosystem. The table below specifies queries that the checksum database must respond to. For each path,$baseis the path portion of the checksum database URL,$moduleis a module path, and$versionis a version. For example, if the checksum database URL ishttps://sum.golang.org, and the client is requesting the record for the modulegolang.org/x/textat versionv0.3.2, the client would send aGETrequest forhttps://sum.golang.org/lookup/golang.org/x/text@v0.3.2. To avoid ambiguity when serving from case-insensitive file systems, the$moduleand$versionelements arecase-encodedby replacing every uppercase letter with an exclamation mark followed by the corresponding lower-case letter. This allows modulesexample.com/Mandexample.com/mto both be stored on disk, since the former is encoded asexample.com/!m. Parts of the path surrounded by square brackets, like[.p/$W]denote optional values. If thegocommand consults the checksum database, then the first step is to retrieve the record data through the/lookupendpoint. If the module version is not yet recorded in the log, the checksum database will try to fetch it from the origin server before replying. This/lookupdata provides the sum for this module version as well as its position in the log, which informs the client of which tiles should be fetched to perform proofs. Thegocommand performs “inclusion” proofs (that a specific record exists in the log) and “consistency” proofs (that the tree hasn’t been tampered with) before adding newgo.sumlines to the main module’sgo.sumfile. It’s important that the data from/lookupshould never be used without first authenticating it against the signed tree hash and authenticating the signed tree hash against the client’s timeline of signed tree hashes. Signed tree hashes and new tiles served by the checksum database are stored in the module cache, so thegocommand only needs to fetch tiles that are missing. Thegocommand doesn’t need to directly connect to the checksum database. It can request module sums via a module proxy thatmirrors the checksum databaseand supports the protocol above. This can be particularly helpful for private, corporate proxies which block requests outside the organization. TheGOSUMDBenvironment variable identifies the name of checksum database to use and optionally its public key and URL, as in: Thegocommand knows the public key ofsum.golang.org, and also that the namesum.golang.google.cn(available inside mainland China) connects to thesum.golang.orgchecksum database; use of any other database requires giving the public key explicitly. The URL defaults tohttps://followed by the database name. GOSUMDBdefaults tosum.golang.org, the Go checksum database run by Google. Seehttps://sum.golang.org/privacyfor the service’s privacy policy. IfGOSUMDBis set tooff, or ifgo getis invoked with the-insecureflag, the checksum database is not consulted, and all unrecognized modules are accepted, at the cost of giving up the security guarantee of verified repeatable downloads for all modules. A better way to bypass the checksum database for specific modules is to use theGOPRIVATEorGONOSUMDBenvironment variables. SeePrivate Modulesfor details. Thego env -wcommand can be used toset these variablesfor futuregocommand invocations. Module behavior in thegocommand may be configured using the environment variables listed below. This list only includes module-related environment variables. Seego help environmentfor a list of all environment variables recognized by thegocommand. Controls whether thegocommand runs in module-aware mode orGOPATHmode. Three values are recognized: SeeModule-aware commandsfor more information. The directory where thegocommand will store downloaded modules and related files. SeeModule cachefor details on the structure of this directory. IfGOMODCACHEis not set, it defaults to$GOPATH/pkg/mod. Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path prefixes that may always be fetched in an insecure manner. Only applies to dependencies that are being fetched directly. Unlike the-insecureflag ongo get,GOINSECUREdoes not disable module checksum database validation.GOPRIVATEorGONOSUMDBmay be used to achieve that. Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path prefixes that should always be fetched directly from version control repositories, not from module proxies. IfGONOPROXYis not set, it defaults toGOPRIVATE. SeePrivacy. Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path prefixes for which thegoshould not verify checksums using the checksum database. IfGONOSUMDBis not set, it defaults toGOPRIVATE. SeePrivacy. InGOPATHmode, theGOPATHvariable is a list of directories that may contain Go code. In module-aware mode, themodule cacheis stored in thepkg/modsubdirectory of the firstGOPATHdirectory. Module source code outside the cache may be stored in any directory. IfGOPATHis not set, it defaults to thegosubdirectory of the user's home directory. List of module proxy URLs, separated by commas (,) or pipes (|). When thegocommand looks up information about a module, it contacts each proxy in the list in sequence until it receives a successful response or a terminal error. A proxy may respond with a 404 (Not Found) or 410 (Gone) status to indicate the module is not available on that server. Thegocommand's error fallback behavior is determined by the separator characters between URLs. If a proxy URL is followed by a comma, thegocommand falls back to the next URL after a 404 or 410 error; all other errors are considered terminal. If the proxy URL is followed by a pipe, thegocommand falls back to the next source after any error, including non-HTTP errors like timeouts. GOPROXYURLs may have the schemeshttps,http, orfile. If a URL has no scheme,httpsis assumed. A module cache may be used directly as a file proxy: Two keywords may be used in place of proxy URLs: GOPROXYdefaults tohttps://proxy.golang.org,direct. Under that configuration, thegocommand first contacts the Go module mirror run by Google, then falls back to a direct connection if the mirror does not have the module. Seehttps://proxy.golang.org/privacyfor the mirror's privacy policy. TheGOPRIVATEandGONOPROXYenvironment variables may be set to prevent specific modules from being downloaded using proxies. SeePrivacyfor information on private proxy configuration. SeeModule proxiesandResolving a package to a modulefor more information on how proxies are used. Identifies the name of the checksum database to use and optionally its public key and URL. For example: Thegocommand knows the public key ofsum.golang.organd also that the namesum.golang.google.cn(available inside mainland China) connects to thesum.golang.orgdatabase; use of any other database requires giving the public key explicitly. The URL defaults tohttps://followed by the database name. GOSUMDBdefaults tosum.golang.org, the Go checksum database run by Google. Seehttps://sum.golang.org/privacyfor the service's privacy policy.IfGOSUMDBis set tooffor ifgo getis invoked with the-insecureflag, the checksum database is not consulted, and all unrecognized modules are accepted, at the cost of giving up the security guarantee of verified repeatable downloads for all modules. A better way to bypass the checksum database for specific modules is to use theGOPRIVATEorGONOSUMDBenvironment variables.SeeAuthenticating modulesandPrivacyfor more information. IfGOSUMDBis set tooffor ifgo getis invoked with the-insecureflag, the checksum database is not consulted, and all unrecognized modules are accepted, at the cost of giving up the security guarantee of verified repeatable downloads for all modules. A better way to bypass the checksum database for specific modules is to use theGOPRIVATEorGONOSUMDBenvironment variables.SeeAuthenticating modulesandPrivacyfor more information. IfGOSUMDBis set tooffor ifgo getis invoked with the-insecureflag, the checksum database is not consulted, and all unrecognized modules are accepted, at the cost of giving up the security guarantee of verified repeatable downloads for all modules. A better way to bypass the checksum database for specific modules is to use theGOPRIVATEorGONOSUMDBenvironment variables. SeeAuthenticating modulesandPrivacyfor more information. Controls the set of version control tools thegocommand may use to download public and private modules (defined by whether their paths match a pattern inGOPRIVATE) or other modules matching a glob pattern. IfGOVCSis not set, or if a module does not match any pattern inGOVCS, thegocommand may usegitandhgfor a public module, or any known version control tool for a private module. Concretely, thegocommand acts as ifGOVCSwere set to: SeeControlling version control tools withGOVCSfor a complete explanation. The GOWORK environment variable instructs the go command to enter workspace mode using the provided [go.work file](#go-work-file) to define the workspace. If GOWORK is set to off workspace mode is disabled. This can be used to run the go command in single module mode: for example, GOWORK=off go build . builds the . package in single-module mode.If GOWORK is empty, the go command will search for a go.work file as described in the [Workspaces](#workspaces) section. build constraint:A condition that determines whether a Go source file is used when compiling a package. Build constraints may be expressed with file name suffixes (for example,foolinuxamd64.go) or with build constraint comments (for example,// +build linux,amd64). SeeBuild Constraints. build list:The list of module versions that will be used for a build command such asgo build,go list, orgo test. The build list is determined from themain module’sgo.modfileandgo.modfiles in transitively required modules usingminimal version selection. The build list contains versions for all modules in themodule graph, not just those relevant to a specific command. canonical version:A correctly formattedversionwithout a build metadata suffix other than+incompatible. For example,v1.2.3is a canonical version, butv1.2.3+metais not. current module:Synonym formain module. deprecated module:A module that is no longer supported by its authors (though major versions are considered distinct modules for this purpose). A deprecated module is marked with adeprecation commentin the latest version of itsgo.modfile. direct dependency:A package whose path appears in animportdeclarationin a.gosource file for a package or test in themain module, or the module containing such a package. (Compareindirect dependency.) direct mode:A setting ofenvironment variablesthat causes thegocommand to download a module directly from aversion control system, as opposed to amodule proxy.GOPROXY=directdoes this for all modules.GOPRIVATEandGONOPROXYdo this for modules matching a list of patterns. go.modfile:The file that defines a module’s path, requirements, and other metadata. Appears in themodule’s root directory. See the section ongo.modfiles. go.workfileThe file that defines the set of modules to be used in aworkspace. See the section ongo.workfiles import path:A string used to import a package in a Go source file. Synonymous withpackage path. indirect dependency:A package transitively imported by a package or test in themain module, but whose path does not appear in anyimportdeclarationin the main module; or a module that appears in themodule graphbut does not provide any package directly imported by the main module. (Comparedirect dependency.) lazy module loading:A change in Go 1.17 that avoids loading themodule graphfor commands that do not need it in modules that specifygo 1.17or higher. SeeLazy module loading. main module:The module in which thegocommand is invoked. The main module is defined by ago.modfilein the current directory or a parent directory. SeeModules, packages, and versions. major version:The first number in a semantic version (1inv1.2.3). In a release with incompatible changes, the major version must be incremented, and the minor and patch versions must be set to 0. Semantic versions with major version 0 are considered unstable. major version subdirectory:A subdirectory within a version control repository matching a module’smajor version suffixwhere a module may be defined. For example, the moduleexample.com/mod/v2in the repository withroot pathexample.com/modmay be defined in the repository root directory or the major version subdirectoryv2. SeeModule directories within a repository. major version suffix:A module path suffix that matches the major version number. For example,/v2inexample.com/mod/v2. Major version suffixes are required atv2.0.0and later and are not allowed at earlier versions. See the section onMajor version suffixes. minimal version selection (MVS):The algorithm used to determine the versions of all modules that will be used in a build. See the section onMinimal version selectionfor details. minor version:The second number in a semantic version (2inv1.2.3). In a release with new, backwards compatible functionality, the minor version must be incremented, and the patch version must be set to 0. module:A collection of packages that are released, versioned, and distributed together. module cache:A local directory storing downloaded modules, located inGOPATH/pkg/mod. SeeModule cache. module graph:The directed graph of module requirements, rooted at themain module. Each vertex in the graph is a module; each edge is a version from arequirestatement in ago.modfile (subject toreplaceandexcludestatements in the main module’sgo.modfile). module graph pruning:A change in Go 1.17 that reduces the size of the module graph by omitting transitive dependencies of modules that specifygo 1.17or higher. SeeModule graph pruning. module path:A path that identifies a module and acts as a prefix for package import paths within the module. For example,"golang.org/x/net". module proxy:A web server that implements theGOPROXYprotocol. Thegocommand downloads version information,go.modfiles, and module zip files from module proxies. module root directory:The directory that contains thego.modfile that defines a module. module subdirectory:The portion of amodule pathafter therepository root paththat indicates the subdirectory where the module is defined. When non-empty, the module subdirectory is also a prefix forsemantic version tags. The module subdirectory does not include themajor version suffix, if there is one, even if the module is in amajor version subdirectory. SeeModule paths. package:A collection of source files in the same directory that are compiled together. See thePackages sectionin the Go Language Specification. package path:The path that uniquely identifies a package. A package path is amodule pathjoined with a subdirectory within the module. For example"golang.org/x/net/html"is the package path for the package in the module"golang.org/x/net"in the"html"subdirectory. Synonym ofimport path. patch version:The third number in a semantic version (3inv1.2.3). In a release with no changes to the module’s public interface, the patch version must be incremented. pre-release version:A version with a dash followed by a series of dot-separated identifiers immediately following the patch version, for example,v1.2.3-beta4. Pre-release versions are considered unstable and are not assumed to be compatible with other versions. A pre-release version sorts before the corresponding release version:v1.2.3-precomes beforev1.2.3. See alsorelease version. pseudo-version:A version that encodes a revision identifier (such as a Git commit hash) and a timestamp from a version control system. For example,v0.0.0-20191109021931-daa7c04131f5. Used forcompatibility with non-module repositoriesand in other situations when a tagged version is not available. release version:A version without a pre-release suffix. For example,v1.2.3, notv1.2.3-pre. See alsopre-release version. repository root path:The portion of amodule paththat corresponds to a version control repository’s root directory. SeeModule paths. retracted version:A version that should not be depended upon, either because it was published prematurely or because a severe problem was discovered after it was published. Seeretractdirective. semantic version tag:A tag in a version control repository that maps aversionto a specific revision. SeeMapping versions to commits. selected version:The version of a given module chosen byminimal version selection. The selected version is the highest version for the module’s path found in themodule graph. vendor directory:A directory namedvendorthat contains packages from other modules needed to build packages in the main module. Maintained withgo mod vendor. SeeVendoring. version:An identifier for an immutable snapshot of a module, written as the lettervfollowed by a semantic version. See the section onVersions. workspace:A collection of modules on disk that are used as the main modules when runningminimal version selection (MVS). See the section onWorkspaces Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Therepository root pathis the portion of the module path that corresponds to the root directory of the version control repository where the module is developed. Most modules are defined in their repository’s root directory, so this is usually the entire path. For example,golang.org/x/netis the repository root path for the module of the same name. SeeFinding a repository for a module pathfor information on how thegocommand locates a repository using HTTP requests derived from a module path. If the module is not defined in the repository’s root directory, themodule subdirectoryis the part of the module path that names the directory, not including the major version suffix. This also serves as a prefix for semantic version tags. For example, the modulegolang.org/x/tools/goplsis in thegoplssubdirectory of the repository with root pathgolang.org/x/tools, so it has the module subdirectorygopls. SeeMapping versions to commitsandModule directories within a repository. If the module is released at major version 2 or higher, the module path must end with amajor version suffixlike/v2. This may or may not be part of the subdirectory name. For example, the module with pathgolang.org/x/repo/sub/v2could be in the/subor/sub/v2subdirectory of the repositorygolang.org/x/repo. Themajor versionmust be incremented and the minor and patch versions must be set to zero after a backwards incompatible change is made to the module’s public interface or documented functionality, for example, after a package is removed. Theminor versionmust be incremented and the patch version set to zero after a backwards compatible change, for example, after a new function is added. Thepatch versionmust be incremented after a change that does not affect the module’s public interface, such as a bug fix or optimization. The pre-release suffix indicates a version is apre-release. Pre-release versions sort before the corresponding release versions. For example,v1.2.3-precomes beforev1.2.3. The build metadata suffix is ignored for the purpose of comparing versions. The go command accepts versions with build metadata and converts them to pseudo-versions to maintain the total ordering between versions. The special suffix+incompatibledenotes a version released before migrating to modules version major version 2 or later (seeCompatibility with non-module repositories). A base version prefix (vX.0.0orvX.Y.Z-0), which is either derived from a semantic version tag that precedes the revision orvX.0.0if there is no such tag. A timestamp (yyyymmddhhmmss), which is the UTC time the revision was created. In Git, this is the commit time, not the author time. A revision identifier (abcdefabcdef), which is a 12-character prefix of the commit hash, or in Subversion, a zero-padded revision number. vX.0.0-yyyymmddhhmmss-abcdefabcdefis used when there is no known base version. As with all versions, the major versionXmust match the module’smajor version suffix. vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdefis used when the base version is a pre-release version likevX.Y.Z-pre. vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdefis used when the base version is a release version likevX.Y.Z. For example, if the base version isv1.2.3, a pseudo-version might bev1.2.4-0.20191109021931-daa7c04131f5. Pseudo-versions with known base versions sort higher than those versions but lower than other pre-release for later versions. Pseudo-versions with the same base version prefix sort chronologically. If a base version is specified, there must be a corresponding semantic version tag that is an ancestor of the revision described by the pseudo-version. This prevents developers from bypassingminimal version selectionusing a pseudo-version that compares higher than all tagged versions likev1.999.999-99999999999999-daa7c04131f5. The timestamp must match the revision’s timestamp. This prevents attackers from floodingmodule proxieswith an unbounded number of otherwise identical pseudo-versions. This also prevents module consumers from changing the relative ordering of versions. The revision must be an ancestor of one of the module repository’s branches or tags. This prevents attackers from referring to unapproved changes or pull requests. Tohttps://corp.example.com/(in parallel):Request for latest version ofgolang.org/x/net/htmlRequest for latest version ofgolang.org/x/netRequest for latest version ofgolang.org/xRequest for latest version ofgolang.org Request for latest version ofgolang.org/x/net/html Request for latest version ofgolang.org/x/net Request for latest version ofgolang.org/x Request for latest version ofgolang.org Tohttps://proxy.golang.org/, if all requests tohttps://corp.example.com/have failed with 404 or 410:Request for latest version ofgolang.org/x/net/htmlRequest for latest version ofgolang.org/x/netRequest for latest version ofgolang.org/xRequest for latest version ofgolang.org Request for latest version ofgolang.org/x/net/html Request for latest version ofgolang.org/x/net Request for latest version ofgolang.org/x Request for latest version ofgolang.org The path must consist of one or more path elements separated by slashes (/, U+002F). It must not begin or end with a slash. Each path element is a non-empty string made of up ASCII letters, ASCII digits, and limited ASCII punctuation (-,.,, and). A path element may not begin or end with a dot (., U+002E). The element prefix up to the first dot must not be a reserved file name on Windows, regardless of case (CON,com1,NuL, and so on). The element prefix up to the first dot must not end with a tilde followed by one or more digits (likeEXAMPL1.COM). The leading path element (up to the first slash, if any), by convention a domain name, must contain only lower-case ASCII letters, ASCII digits, dots (., U+002E), and dashes (-, U+002D); it must contain at least one dot and cannot start with a dash. For a final path element of the form/vNwhereNlooks numeric (ASCII digits and dots),Nmust not begin with a leading zero, must not be/v1, and must not contain any dots.For paths beginning withgopkg.in/, this requirement is replaced by a requirement that the path follow thegopkg.inservice’s conventions. For paths beginning withgopkg.in/, this requirement is replaced by a requirement that the path follow thegopkg.inservice’s conventions. For packages within the module, the compiler rejects use of language features introduced after the version specified by thegodirective. For example, if a module has the directivego 1.12, its packages may not use numeric literals like1000000, which were introduced in Go 1.13. If an older Go version builds one of the module’s packages and encounters a compile error, the error notes that the module was written for a newer Go version. For example, suppose a module hasgo 1.13and a package uses the numeric literal1000000. If that package is built with Go 1.12, the compiler notes that the code is written for Go 1.13. Atgo 1.14or higher, automaticvendoringmay be enabled. If the filevendor/modules.txtis present and consistent withgo.mod, there is no need to explicitly use the-mod=vendorflag. Atgo 1.16or higher, theallpackage pattern matches only packages transitively imported by packages and tests in themain module. This is the same set of packages retained bygo mod vendorsince modules were introduced. In lower versions,allalso includes tests of packages imported by packages in the main module, tests of those packages, and so on. Atgo 1.17or higher:Thego.modfile includes an explicitrequiredirectivefor each module that provides any package transitively imported by a package or test in the main module. (Atgo 1.16and lower, anindirect dependencyis included only ifminimal version selectionwould otherwise select a different version.) This extra information enablesmodule graph pruningandlazy module loading.Because there may be many more// indirectdependencies than in previousgoversions, indirect dependencies are recorded in a separate block within thego.modfile.go mod vendoromitsgo.modandgo.sumfiles for vendored dependencies. (That allows invocations of thegocommand within subdirectories ofvendorto identify the correct main module.)go mod vendorrecords thegoversion from each dependency’sgo.modfile invendor/modules.txt. Thego.modfile includes an explicitrequiredirectivefor each module that provides any package transitively imported by a package or test in the main module. (Atgo 1.16and lower, anindirect dependencyis included only ifminimal version selectionwould otherwise select a different version.) This extra information enablesmodule graph pruningandlazy module loading. Because there may be many more// indirectdependencies than in previousgoversions, indirect dependencies are recorded in a separate block within thego.modfile. go mod vendoromitsgo.modandgo.sumfiles for vendored dependencies. (That allows invocations of thegocommand within subdirectories ofvendorto identify the correct main module.) go mod vendorrecords thegoversion from each dependency’sgo.modfile invendor/modules.txt. Atgo 1.21or higher:Thegoline declares a required minimum version of Go to use with this module.Thegoline must be greater than or equal to thegoline of all dependencies.Thegocommand no longer attempts to maintain compatibility with the previous older version of Go.Thegocommand is more careful about keeping checksums ofgo.modfiles in thego.sumfile. Thegoline declares a required minimum version of Go to use with this module. Thegoline must be greater than or equal to thegoline of all dependencies. Thegocommand no longer attempts to maintain compatibility with the previous older version of Go. Thegocommand is more careful about keeping checksums ofgo.modfiles in thego.sumfile. Retracting all versions betweenv1.0.0andv1.9.9: Returning to unversioned after prematurely released a versionv1.0.0: Wiping out a module including all pseudo-versions and tagged versions: A checked-ingo.workfile might override a developer’s owngo.workfile from a parent directory, causing confusion when theirusedirectives don’t apply. A checked-ingo.workfile may cause a continuous integration (CI) system to select and thus test the wrong versions of a module’s dependencies. CI systems should generally not be allowed to use thego.workfile so that they can test the behavior of the module as it would be used when required by other modules, where ago.workfile within the module has no effect. When resolving an import of the form$modpath/$vn/$dirwhere:$modpathis a valid module path,$vnis a major version suffix,$diris a possibly empty subdirectory, $modpathis a valid module path, $vnis a major version suffix, $diris a possibly empty subdirectory, If all of the following are true:The package$modpath/$vn/$diris not present in any relevantvendordirectory.Ago.modfile is present in the same directory as the importing file or in any parent directory up to the$GOPATH/srcroot,No$GOPATH[i]/src/$modpath/$vn/$suffixdirectory exists (for any root$GOPATH[i]),The file$GOPATH[d]/src/$modpath/go.modexists (for some root$GOPATH[d]) and declares the module path as$modpath/$vn, The package$modpath/$vn/$diris not present in any relevantvendordirectory. Ago.modfile is present in the same directory as the importing file or in any parent directory up to the$GOPATH/srcroot, No$GOPATH[i]/src/$modpath/$vn/$suffixdirectory exists (for any root$GOPATH[i]), The file$GOPATH[d]/src/$modpath/go.modexists (for some root$GOPATH[d]) and declares the module path as$modpath/$vn, Then the import of$modpath/$vn/$diris resolved to the directory$GOPATH[d]/src/$modpath/$dir. IfGO111MODULE=off, thegocommand ignoresgo.modfiles and runs inGOPATHmode. IfGO111MODULE=onor is unset, thegocommand runs in module-aware mode, even when nogo.modfile is present. Not all commands work without ago.modfile: seeModule commands outside a module. IfGO111MODULE=auto, thegocommand runs in module-aware mode if ago.modfile is present in the current directory or any parent directory. In Go 1.15 and lower, this was the default behavior.go modsubcommands andgo installwith aversion queryrun in module-aware mode even if nogo.modfile is present. go build go fix go generate go install go list go run go test go vet The-modflag controls whethergo.modmay be automatically updated and whether thevendordirectory is used.-mod=modtells thegocommand to ignore the vendor directory and toautomatically updatego.mod, for example, when an imported package is not provided by any known module.-mod=readonlytells thegocommand to ignore thevendordirectory and to report an error ifgo.modneeds to be updated.-mod=vendortells thegocommand to use thevendordirectory. In this mode, thegocommand will not use the network or the module cache.By default, if thegoversioningo.modis1.14or higher and avendordirectory is present, thegocommand acts as if-mod=vendorwere used. Otherwise, thegocommand acts as if-mod=readonlywere used.go getrejects this flag as the purpose of the command is to modify dependencies, which is only allowed by-mod=mod. -mod=modtells thegocommand to ignore the vendor directory and toautomatically updatego.mod, for example, when an imported package is not provided by any known module. -mod=readonlytells thegocommand to ignore thevendordirectory and to report an error ifgo.modneeds to be updated. -mod=vendortells thegocommand to use thevendordirectory. In this mode, thegocommand will not use the network or the module cache. By default, if thegoversioningo.modis1.14or higher and avendordirectory is present, thegocommand acts as if-mod=vendorwere used. Otherwise, thegocommand acts as if-mod=readonlywere used. go getrejects this flag as the purpose of the command is to modify dependencies, which is only allowed by-mod=mod. The-modcacherwflag instructs thegocommand to create new directories in the module cache with read-write permissions instead of making them read-only. When this flag is used consistently (typically by settingGOFLAGS=-modcacherwin the environment or by runninggo env -w GOFLAGS=-modcacherw), the module cache may be deleted with commands likerm -rwithout changing permissions first. Thego clean -modcachecommand may be used to delete the module cache, whether or not-modcacherwwas used. The-modfile=file.modflag instructs thegocommand to read (and possibly write) an alternate file instead ofgo.modin the module root directory. The file’s name must end with.mod. A file namedgo.modmust still be present in order to determine the module root directory, but it is not accessed. When-modfileis specified, an alternatego.sumfile is also used: its path is derived from the-modfileflag by trimming the.modextension and appending.sum. The-dflag tellsgo getnot to build or install packages. When-dis used,go getwill only manage dependencies ingo.mod. Usinggo getwithout-dto build and install packages is deprecated (as of Go 1.17). In Go 1.18,-dwill always be enabled. The-uflag tellsgo getto upgrade modules providing packages imported directly or indirectly by packages named on the command line. Each module selected by-uwill be upgraded to its latest version unless it is already required at a higher version (a pre-release). The-u=patchflag (not-u patch) also tellsgo getto upgrade dependencies, butgo getwill upgrade each dependency to the latest patch version (similar to the@patchversion query). The-tflag tellsgo getto consider modules needed to build tests of packages named on the command line. When-tand-uare used together,go getwill update test dependencies as well. The-insecureflag should no longer be used. It permitsgo getto resolve custom import paths and fetch from repositories and module proxies using insecure schemes such as HTTP. TheGOINSECUREenvironment variableprovides more fine-grained control and should be used instead. Arguments must be package paths or package patterns (with “...” wildcards). They must not be standard packages (likefmt), meta-patterns (std,cmd,all), or relative or absolute file paths. All arguments must have the same version suffix. Different queries are not allowed, even if they refer to the same version. All arguments must refer to packages in the same module at the same version. Package path arguments must refer tomainpackages. Pattern arguments will only matchmainpackages. No module is considered themain module.If the module containing packages named on the command line has ago.modfile, it must not contain directives (replaceandexclude) that would cause it to be interpreted differently if it were the main module.The module must not require a higher version of itself.Vendor directories are not used in any module. (Vendor directories are not included inmodule zip files, sogo installdoes not download them.) If the module containing packages named on the command line has ago.modfile, it must not contain directives (replaceandexclude) that would cause it to be interpreted differently if it were the main module. The module must not require a higher version of itself. Vendor directories are not used in any module. (Vendor directories are not included inmodule zip files, sogo installdoes not download them.) The-moduleflag changes the module’s path (thego.modfile’s module line). The-go=versionflag sets the expected Go language version. The-require=path@versionand-droprequire=pathflags add and drop a requirement on the given module path and version. Note that-requireoverrides any existing requirements onpath. These flags are mainly for tools that understand the module graph. Users should prefergo get path@versionorgo get path@none, which make othergo.modadjustments as needed to satisfy constraints imposed by other modules. Seego get. The-exclude=path@versionand-dropexclude=path@versionflags add and drop an exclusion for the given module path and version. Note that-exclude=path@versionis a no-op if that exclusion already exists. The-replace=old[@v]=new[@v]flag adds a replacement of the given module path and version pair. If the@vinold@vis omitted, a replacement without a version on the left side is added, which applies to all versions of the old module path. If the@vinnew@vis omitted, the new path should be a local module root directory, not a module path. Note that-replaceoverrides any redundant replacements forold[@v], so omitting@vwill drop replacements for specific versions. The-dropreplace=old[@v]flag drops a replacement of the given module path and version pair. If the@vis provided, a replacement with the given version is dropped. An existing replacement without a version on the left side may still replace the module. If the@vis omitted, a replacement without a version is dropped. The-retract=versionand-dropretract=versionflags add and drop a retraction for the given version, which may be a single version (likev1.2.3) or an interval (like[v1.1.0,v1.2.0]). Note that the-retractflag cannot add a rationale comment for theretractdirective. Rationale comments are recommended and may be shown bygo list -m -uand other commands. The-tool=pathand-droptool=pathflags add and drop atooldirective for the given paths. Note that this will not add necessary dependencies to the build graph. Users should prefergo get -tool pathto add a tool, orgo get -tool path@noneto remove one. The-fmtflag reformats thego.modfile without making other changes. This reformatting is also implied by any other modifications that use or rewrite thego.modfile. The only time this flag is needed is if no other flags are specified, as ingo mod edit -fmt. The-printflag prints the finalgo.modin its text format instead of writing it back to disk. The-jsonflag prints the finalgo.modin JSON format instead of writing it back to disk in text format. The JSON output corresponds to these Go types: GLOCKFILE(Glock) Godeps/Godeps.json(Godeps) Gopkg.lock(dep) dependencies.tsv(godeps) glide.lock(glide) vendor.conf(trash) vendor.yml(govend) vendor/manifest(gvt) vendor/vendor.json(govendor) path: the path of themainpackage used to build the executable. mod: the module containing themainpackage. The columns are the module path, version, and sum, respectively. Themain modulehas the version(devel)and no sum. dep: a module that provided one or more packages linked into the executable. Same format asmod. =>: areplacementfor the module on the previous line. If the replacement is a local directory, only the directory path is listed (no version or sum). If the replacement is a module version, the path, version, and sum are listed, as withmodanddep. A replaced module has no sum. A fully-specified semantic version, such asv1.2.3, which selects a specific version. SeeVersionsfor syntax. A semantic version prefix, such asv1orv1.2, which selects the highest available version with that prefix. A semantic version comparison, such as=v1.5.6, which selects the nearest available version to the comparison target (the lowest version for>and>=, and the highest version for example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5]  go require ( example.com/new/thing/v2 v2.3.4 example.com/old/thing v1.2.3 )  go GoMod = { Directive } . Directive = ModuleDirective | GoDirective | ToolDirective | RequireDirective | ExcludeDirective | ReplaceDirective | RetractDirective .  go ModulePath = ident | string . / see restrictions above / Version = ident | string . / see restrictions above /  go ModuleDirective = "module" ( ModulePath | "(" newline ModulePath newline ")" ) newline .  go module golang.org/x/net  go // Deprecated: use example.com/mod/v2 instead. module example.com/mod  go GoDirective = "go" GoVersion newline . GoVersion = string | ident . / valid release version; see above /  go go 1.23.0  go ToolchainDirective = "toolchain" ToolchainName newline . ToolchainName = string | ident . / valid toolchain name; see “Go toolchains” /  go toolchain go1.21.0  go GodebugDirective = "godebug" ( GodebugSpec | "(" newline { GodebugSpec } ")" newline ) . GodebugSpec = GodebugKey "=" GodebugValue newline. GodebugKey = GodebugChar { GodebugChar }. GodebugValue = GodebugChar { GodebugChar }. GodebugChar = any non-space character except , "  ' (comma and quotes).  go godebug default=go1.21 godebug ( panicnil=1 asynctimerchan=0 )  go RequireDirective = "require" ( RequireSpec | "(" newline { RequireSpec } ")" newline ) . RequireSpec = ModulePath Version newline .  go require golang.org/x/net v1.2.3 require ( golang.org/x/crypto v1.4.5 // indirect golang.org/x/text v1.6.7 )  go ToolDirective = "tool" ( ToolSpec | "(" newline { ToolSpec } ")" newline ) . ToolSpec = ModulePath newline .  go tool golang.org/x/tools/cmd/stringer tool ( example.com/module/cmd/a example.com/module/cmd/b )  go ExcludeDirective = "exclude" ( ExcludeSpec | "(" newline { ExcludeSpec } ")" newline ) . ExcludeSpec = ModulePath Version newline .  go exclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 )  go ReplaceDirective = "replace" ( ReplaceSpec | "(" newline { ReplaceSpec } ")" newline ) . ReplaceSpec = ModulePath [ Version ] "=>" FilePath newline | ModulePath [ Version ] "=>" ModulePath Version newline . FilePath = / platform-specific relative or absolute file path /  go replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 golang.org/x/net => example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 => ./fork/net golang.org/x/net => ./fork/net )  go retract ( v1.0.0 // Published accidentally. v1.0.1 // Contains retractions only. )  go RetractDirective = "retract" ( RetractSpec | "(" newline { RetractSpec } ")" newline ) . RetractSpec = ( Version | "[" Version "," Version "]" ) newline .  go retract v1.0.0 retract [v1.0.0, v1.9.9] retract ( v1.0.0 [v1.0.0, v1.9.9] )  go retract [v0.0.0, v1.0.1] // assuming v1.0.1 contains this retraction.  go retract [v0.0.0-0, v0.15.2] // assuming v0.15.2 contains this retraction.  go module example.com/M go 1.23.0 require ( example.com/A v1 example.com/B v1.0.0 example.com/C v1.0.0 example.com/D v1.2.3 example.com/E dev ) exclude example.com/D v1.2.3  go go 1.23.0 use ./my/first/thing use ./my/second/thing replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5  go use ( ./my/first/thing ./my/second/thing )  go GoWork = { Directive } . Directive = GoDirective | ToolchainDirective | UseDirective | ReplaceDirective .  go ModulePath = ident | string . / see restrictions above / Version = ident | string . / see restrictions above /  go GoDirective = "go" GoVersion newline . GoVersion = string | ident . / valid release version; see above /  go go 1.23.0  go ToolchainDirective = "toolchain" ToolchainName newline . ToolchainName = string | ident . / valid toolchain name; see “Go toolchains” /  go toolchain go1.21.0  go UseDirective = "use" ( UseSpec | "(" newline { UseSpec } ")" newline ) . UseSpec = FilePath newline . FilePath = / platform-specific relative or absolute file path /  go use ./mymod // example.com/mymod use ( ../othermod ./subdir/thirdmod )  go ReplaceDirective = "replace" ( ReplaceSpec | "(" newline { ReplaceSpec } ")" newline ) . ReplaceSpec = ModulePath [ Version ] "=>" FilePath newline | ModulePath [ Version ] "=>" ModulePath Version newline . FilePath = / platform-specific relative or absolute file path /  go replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 golang.org/x/net => example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 => ./fork/net golang.org/x/net => ./fork/net )  go require example.com/m v4.1.2+incompatible  go go get [-d] [-t] [-u] [build flags] [packages]  go # Upgrade a specific module. $ go get golang.org/x/net # Upgrade modules that provide packages imported by packages in the main module. $ go get -u ./... # Upgrade or downgrade to a specific version of a module. $ go get golang.org/x/text@v0.3.2 # Update to the commit on the module's master branch. $ go get golang.org/x/text@master # Remove a dependency on a module and downgrade modules that require it # to versions that don't require it. $ go get golang.org/x/text@none # Upgrade the minimum required Go version for the main module. $ go get go # Upgrade the suggested Go toolchain, leaving the minimum Go version alone. $ go get toolchain # Upgrade to the latest patch release of the suggested Go toolchain. $ go get toolchain@patch  go go install [build flags] [packages]  go # Install the latest version of a program, # ignoring go.mod in the current directory (if any). $ go install golang.org/x/tools/gopls@latest # Install a specific version of a program. $ go install golang.org/x/tools/gopls@v0.6.4 # Install a program at the version selected by the module in the current directory. $ go install golang.org/x/tools/gopls # Install all programs in a directory. $ go install ./cmd/...  go go list -m [-u] [-retracted] [-versions] [list flags] [modules]  go $ go list -m all $ go list -m -versions example.com/m $ go list -m -json example.com/m@latest  go type Module struct { Path string // module path Version string // module version Versions []string // available module versions Replace Module // replaced by this module Time time.Time // time version was created Update Module // available update (with -u) Main bool // is this the main module? Indirect bool // module is only indirectly needed by main module Dir string // directory holding local copy of files, if any GoMod string // path to go.mod file describing module, if any GoVersion string // go version used in module Retracted []string // retraction information, if any (with -retracted or -u) Deprecated string // deprecation message, if any (with -u) Error ModuleError // error loading module } type ModuleError struct { Err string // the error itself }  go example.com/main/module golang.org/x/net v0.1.0 golang.org/x/text v0.3.0 => /tmp/text rsc.io/pdf v0.1.1  go example.com/main/module golang.org/x/old v1.9.9 (deprecated) golang.org/x/net v0.1.0 (retracted) [v0.2.0] golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text rsc.io/pdf v0.1.1 [v0.1.2]  go go mod download [-x] [-json] [-reuse=old.json] [modules]  go $ go mod download $ go mod download golang.org/x/mod@v0.2.0  go type Module struct { Path string // module path Query string // version query corresponding to this version Version string // module version Error string // error loading module Info string // absolute path to cached .info file GoMod string // absolute path to cached .mod file Zip string // absolute path to cached .zip file Dir string // absolute path to cached source root directory Sum string // checksum for path, version (as in go.sum) GoModSum string // checksum for go.mod (as in go.sum) Origin any // provenance of module Reuse bool // reuse of old module info is safe }  go go mod edit [editing flags] [-fmt|-print|-json] [go.mod]  go # Add a replace directive. $ go mod edit -replace example.com/a@v1.0.0=./a # Remove a replace directive. $ go mod edit -dropreplace example.com/a@v1.0.0 # Set the go version, add a requirement, and print the file # instead of writing it to disk. $ go mod edit -go=1.14 -require=example.com/m@v1.0.0 -print # Format the go.mod file. $ go mod edit -fmt # Format and print a different .mod file. $ go mod edit -print tools.mod # Print a JSON representation of the go.mod file. $ go mod edit -json  go type Module struct { Path string Version string } type GoMod struct { Module ModPath Go string Require []Require Exclude []Module Replace []Replace Retract []Retract } type ModPath struct { Path string Deprecated string } type Require struct { Path string Version string Indirect bool } type Replace struct { Old Module New Module } type Retract struct { Low string High string Rationale string } type Tool struct { Path string }  go go mod graph [-go=version]  go example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0  go go mod init [module-path]  go go mod init go mod init example.com/m  go go mod tidy [-e] [-v] [-x] [-diff] [-go=version] [-compat=version]  go go mod vendor [-e] [-v] [-o]  go go mod verify  go go mod why [-m] [-vendor] packages...  go $ go mod why golang.org/x/text/language golang.org/x/text/encoding # golang.org/x/text/language rsc.io/quote rsc.io/sampler golang.org/x/text/language # golang.org/x/text/encoding (main module does not need package golang.org/x/text/encoding)  go go version [-m] [-v] [file ...]  go # Print Go version used to build go. $ go version # Print Go version used to build a specific executable. $ go version /go/bin/gopls # Print Go version and module versions used to build a specific executable. $ go version -m /go/bin/gopls # Print Go version and module versions used to build executables in a directory. $ go version -m /go/bin/  go $ go version -m /go/bin/goimports /home/jrgopher/go/bin/goimports: go1.14.3 path golang.org/x/tools/cmd/goimports mod golang.org/x/tools v0.0.0-20200518203908-8018eb2c26ba h1:0Lcy64USfQQL6GAJma8BdHCgeofcchQj+Z7j0SXYAzU= dep golang.org/x/mod v0.2.0 h1:KU7oHjnv3XNWfa5COkzUifxZmxp1TyI7ImMXqFxLwvQ= dep golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=  go go clean [-modcache]  go go env -w GOFLAGS=-modcacherw  go go get example.com/m@latest go mod download example.com/m@master go list -m -json example.com/m@e3702bed2  go go work init [moddirs]  go go work edit [editing flags] [go.work]  go type Module struct { Path string Version string } type GoWork struct { Go string Directory []Directory Replace []Replace } type Use struct { Path string ModulePath string } type Replace struct { Old Module New Module }  go go work use [-r] [moddirs]  go go work sync  go type Info struct { Version string // version string Time time.Time // commit time }  go $ curl https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.mod module golang.org/x/mod go 1.12 require ( golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550 golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898 )  go $ curl -O https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.zip $ unzip -l v0.2.0.zip | head Archive: v0.2.0.zip Length Date Time Name --------- ---------- ----- ---- 1479 00-00-1980 00:00 golang.org/x/mod@v0.2.0/LICENSE 1303 00-00-1980 00:00 golang.org/x/mod@v0.2.0/PATENTS 559 00-00-1980 00:00 golang.org/x/mod@v0.2.0/README 21 00-00-1980 00:00 golang.org/x/mod@v0.2.0/codereview.cfg 214 00-00-1980 00:00 golang.org/x/mod@v0.2.0/go.mod 1476 00-00-1980 00:00 golang.org/x/mod@v0.2.0/go.sum 5224 00-00-1980 00:00 golang.org/x/mod@v0.2.0/gosumcheck/main.go  go $ curl https://proxy.golang.org/golang.org/x/mod/@v/list v0.1.0 v0.2.0 $ curl https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.info {"Version":"v0.2.0","Time":"2020-01-02T17:33:45Z"}  go  go https://golang.org/x/mod?go-get=1 (preferred) http://golang.org/x/mod?go-get=1 (fallback, only with GOINSECURE)  go  go  go go get example.com/mod@master  go GOVCS=github.com:git,evil.com:off,:git|hg  go GOVCS=:all  go GOVCS=:off  go GOPROXY=https://proxy.corp.example.com GONOSUMDB=corp.example.com  go GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org,direct GONOSUMDB=corp.example.com  go GOPRIVATE=corp.example.com  go machine proxy.corp.example.com login jrgopher password hunter2  go GOPROXY=https://jrgopher:hunter2@proxy.corp.example.com  go [url "git@github.com:"] insteadOf = https://github.com/  go https://proxy.golang.org,direct  go GOPRIVATE=.corp.example.com,.research.example.com  go GOPROXY=https://proxy.corp.example.com GONOSUMDB=.corp.example.com,.research.example.com  go GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org GONOSUMDB=.corp.example.com,.research.example.com  go go mod download corp.example.com/secret-product/typo@latest  go GOSUMDB="sum.golang.org" GOSUMDB="sum.golang.org+" GOSUMDB="sum.golang.org+ https://sum.golang.org"  go GOPROXY=file://$(go env GOMODCACHE)/cache/download  go GOSUMDB="sum.golang.org" GOSUMDB="sum.golang.org+" GOSUMDB="sum.golang.org+ https://sum.golang.org"  go public:git|hg,private:all  go.mod go "golang.org/x/net" "html" "golang.org/x/net/html" module golang.org/x/net golang.org/x/tools/gopls gopls golang.org/x/tools /v2 golang.org/x/repo/sub/v2 /sub /sub/v2 golang.org/x/repo example test v v0.0.0 v1.12.134 v8.0.5-pre v2.0.9+meta v1.2.3-pre v1.2.3 +incompatible v0.2.0 v0.1.0 v1.5.0-beta v1.5.0 go get golang.org/x/net@daa7c041 daa7c041 v0.0.0-20191109021931-daa7c04131f5 master vX.0.0 vX.Y.Z-0 yyyymmddhhmmss abcdefabcdef vX.0.0-yyyymmddhhmmss-abcdefabcdef X vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef vX.Y.Z-pre vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef vX.Y.Z v1.2.4-0.20191109021931-daa7c04131f5 v1.999.999-99999999999999-daa7c04131f5 go get example.com/mod@master go list -m -json example.com/mod@abcd1234 example.com/mod v1.0.0 example.com/mod/v2 v2.0.0 v2 v0 v1 gopkg.in/ gopkg.in/yaml.v2 v2.0.0+incompatible example.com/a/b example.com/a b .go -mod=mod go.sum go get go mod tidy GOPROXY direct off GOPRIVATE GONOPROXY golang.org/x/net/html https://corp.example.com,https://proxy.golang.org https://corp.example.com/ golang.org/x golang.org https://proxy.golang.org/ // indirect module example.com/my/thing go 1.23.0 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] require ( example.com/new/thing/v2 v2.3.4 example.com/old/thing v1.2.3 ) go mod edit golang.org/x/mod/modfile // / / ( ) => require replace exclude retract "  \ \" \n n / - .   CON com1 NuL EXAMPL1.COM /vN N /v1 GoMod = { Directive } . Directive = ModuleDirective | GoDirective | ToolDirective | RequireDirective | ExcludeDirective | ReplaceDirective | RetractDirective . newline ident string ModulePath Version ModulePath = ident | string . / see restrictions above / Version = ident | string . / see restrictions above / ModuleDirective = "module" ( ModulePath | "(" newline ModulePath newline ")" ) newline . module golang.org/x/net Deprecated: // Deprecated: use example.com/mod/v2 instead. module example.com/mod go list -m -u @latest // Deprecated: 1.14 1.21rc1 1.23.0 go 1.12 1000000 go 1.13 go 1.14 vendor/modules.txt -mod=vendor go 1.16 all go mod vendor go 1.17 vendor go 1.21 GoDirective = "go" GoVersion newline . GoVersion = string | ident . / valid release version; see above / go 1.23.0 toolchain ToolchainDirective = "toolchain" ToolchainName newline . ToolchainName = string | ident . / valid toolchain name; see “Go toolchains” / toolchain go1.21.0 godebug godebug key=value //go:debug key=value GodebugDirective = "godebug" ( GodebugSpec | "(" newline { GodebugSpec } ")" newline ) . GodebugSpec = GodebugKey "=" GodebugValue newline. GodebugKey = GodebugChar { GodebugChar }. GodebugValue = GodebugChar { GodebugChar }. GodebugChar = any non-space character except , "  ' (comma and quotes). godebug default=go1.21 godebug ( panicnil=1 asynctimerchan=0 ) go get -u ./... RequireDirective = "require" ( RequireSpec | "(" newline { RequireSpec } ")" newline ) . RequireSpec = ModulePath Version newline . require golang.org/x/net v1.2.3 require ( golang.org/x/crypto v1.4.5 // indirect golang.org/x/text v1.6.7 ) tool go tool ToolDirective = "tool" ( ToolSpec | "(" newline { ToolSpec } ")" newline ) . ToolSpec = ModulePath newline . tool golang.org/x/tools/cmd/stringer tool ( example.com/module/cmd/a example.com/module/cmd/b ) go list -m -versions ExcludeDirective = "exclude" ( ExcludeSpec | "(" newline { ExcludeSpec } ")" newline ) . ExcludeSpec = ModulePath Version newline . exclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 ) ./ ../ go.work file ReplaceDirective = "replace" ( ReplaceSpec | "(" newline { ReplaceSpec } ")" newline ) . ReplaceSpec = ModulePath [ Version ] "=>" FilePath newline | ModulePath [ Version ] "=>" ModulePath Version newline . FilePath = / platform-specific relative or absolute file path / replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 golang.org/x/net => example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 => ./fork/net golang.org/x/net => ./fork/net ) go list -m -retracted $modpath@latest $modpath -retracted @>=v1.2.3 example.com/m v1.0.1 retract ( v1.0.0 // Published accidentally. v1.0.1 // Contains retractions only. ) go get example.com/m@latest v0.9.5 [ ] [v1.1.0, v1.2.0] go list RetractDirective = "retract" ( RetractSpec | "(" newline { RetractSpec } ")" newline ) . RetractSpec = ( Version | "[" Version "," Version "]" ) newline . v1.9.9 retract v1.0.0 retract [v1.0.0, v1.9.9] retract ( v1.0.0 [v1.0.0, v1.9.9] ) retract [v0.0.0, v1.0.1] // assuming v1.0.1 contains this retraction. retract [v0.0.0-0, v0.15.2] // assuming v0.15.2 contains this retraction. go build go test module example.com/M go 1.23.0 require ( example.com/A v1 example.com/B v1.0.0 example.com/C v1.0.0 example.com/D v1.2.3 example.com/E dev ) exclude example.com/D v1.2.3 example.com/A example.com/E dev v0.0.0-20180523231146-b3f5c0f6e5f1 example.com/D v1.2.3 example.com/D v1.2.4 v1.3.0 example.com/A v1.0.0 example.com/B v1.2.0 example.com/C v1.0.0 example.com/B v1.0.0 v1.2.0 example.com/B example.com/C go install -mod=readonly go.work go list -m all @none go 1.18 -compat go mod init go mod why GOWORK go env GOWORK go 1.23.0 use ./my/first/thing use ./my/second/thing replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 use ( ./my/first/thing ./my/second/thing ) go work init go work use go work edit go.work.sum use go.mod files GoWork = { Directive } . Directive = GoDirective | ToolchainDirective | UseDirective | ReplaceDirective . 1.18 1.19 UseDirective = "use" ( UseSpec | "(" newline { UseSpec } ")" newline ) . UseSpec = FilePath newline . FilePath = / platform-specific relative or absolute file path / use ./mymod // example.com/mymod use ( ../othermod ./subdir/thirdmod ) GOPATH 2 require example.com/m v4.1.2+incompatible v4.1.2+incompatible v4.1.2 v1.5.2 example.com/m/v5 v5.0.0 v2.0.1-20200722182040-012345abcdef+incompatible example.com/repo sub $GOPATH/src/example.com/repo/sub example.com/repo/sub example.com/repo/v2/sub $GOPATH/src/example.com/repo/v2/sub $modpath/$vn/$dir $vn $dir $GOPATH/src $GOPATH[i]/src/$modpath/$vn/$suffix $GOPATH[i] $GOPATH[d]/src/$modpath/go.mod $GOPATH[d] $modpath/$vn $GOPATH[d]/src/$modpath/$dir GO111MODULE on auto GO111MODULE=off GO111MODULE=on GO111MODULE=auto go mod GOPATH/pkg/mod GOPATH/bin GOBIN go fix go generate go run go vet -mod -modcacherw GOFLAGS=-modcacherw go env -w GOFLAGS=-modcacherw rm -r go clean -modcache -modfile=file.mod .mod -modfile .sum ignore go list -m go version -m go mod download go get [-d] [-t] [-u] [build flags] [packages] # Upgrade a specific module. $ go get golang.org/x/net # Upgrade modules that provide packages imported by packages in the main module. $ go get -u ./... # Upgrade or downgrade to a specific version of a module. $ go get golang.org/x/text@v0.3.2 # Update to the commit on the module's master branch. $ go get golang.org/x/text@master # Remove a dependency on a module and downgrade modules that require it # to versions that don't require it. $ go get golang.org/x/text@none # Upgrade the minimum required Go version for the main module. $ go get go # Upgrade the suggested Go toolchain, leaving the minimum Go version alone. $ go get toolchain # Upgrade to the latest patch release of the suggested Go toolchain. $ go get toolchain@patch ... -u go get golang.org/x/text@v0.3.0 @ v0.3.0 v0.3 1234abcd latest upgrade patch none @upgrade example.com/b v1.1.0 go get example.com/a@v1.5.0 go list -m -u all $GOPATH/bin $HOME/go/bin -d -u=patch -u patch @patch -t -insecure GOINSECURE @v1.4.6 go install [build flags] [packages] # Install the latest version of a program, # ignoring go.mod in the current directory (if any). $ go install golang.org/x/tools/gopls@latest # Install a specific version of a program. $ go install golang.org/x/tools/gopls@v0.6.4 # Install a program at the version selected by the module in the current directory. $ go install golang.org/x/tools/gopls # Install all programs in a directory. $ go install ./cmd/... main $GOROOT $GOROOT/bin $GOTOOLDIR $GOBIN @v1.0.0 fmt std cmd go list -m [-u] [-retracted] [-versions] [list flags] [modules] $ go list -m all $ go list -m -versions example.com/m $ go list -m -json example.com/m@latest -m -f Module type Module struct { Path string // module path Version string // module version Versions []string // available module versions Replace Module // replaced by this module Time time.Time // time version was created Update Module // available update (with -u) Main bool // is this the main module? Indirect bool // module is only indirectly needed by main module Dir string // directory holding local copy of files, if any GoMod string // path to go.mod file describing module, if any GoVersion string // go version used in module Retracted []string // retraction information, if any (with -retracted or -u) Deprecated string // deprecation message, if any (with -u) Error ModuleError // error loading module } type ModuleError struct { Err string // the error itself } example.com/main/module golang.org/x/net v0.1.0 golang.org/x/text v0.3.0 => /tmp/text rsc.io/pdf v0.1.1 String -f '{{.String}}' Replace Dir Replace.Dir list -u Update example.com/main/module golang.org/x/old v1.9.9 (deprecated) golang.org/x/net v0.1.0 (retracted) [v0.2.0] golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text rsc.io/pdf v0.1.1 [v0.1.2] go list -m -u -json all -versions list Versions go list -m -retracted example.com/m@latest Error go mod download [-x] [-json] [-reuse=old.json] [modules] $ go mod download $ go mod download golang.org/x/mod@v0.2.0 path@version download -json type Module struct { Path string // module path Query string // version query corresponding to this version Version string // module version Error string // error loading module Info string // absolute path to cached .info file GoMod string // absolute path to cached .mod file Zip string // absolute path to cached .zip file Dir string // absolute path to cached source root directory Sum string // checksum for path, version (as in go.sum) GoModSum string // checksum for go.mod (as in go.sum) Origin any // provenance of module Reuse bool // reuse of old module info is safe } -x go mod edit [editing flags] [-fmt|-print|-json] [go.mod] # Add a replace directive. $ go mod edit -replace example.com/a@v1.0.0=./a # Remove a replace directive. $ go mod edit -dropreplace example.com/a@v1.0.0 # Set the go version, add a requirement, and print the file # instead of writing it to disk. $ go mod edit -go=1.14 -require=example.com/m@v1.0.0 -print # Format the go.mod file. $ go mod edit -fmt # Format and print a different .mod file. $ go mod edit -print tools.mod # Print a JSON representation of the go.mod file. $ go mod edit -json -module -go=version -require=path@version -droprequire=path -require path go get path@version go get path@none -exclude=path@version -dropexclude=path@version -replace=old[@v]=new[@v] @v old@v new@v -replace old[@v] -dropreplace=old[@v] -retract=version -dropretract=version [v1.1.0,v1.2.0] -retract -tool=path -droptool=path go get -tool path go get -tool path@none -fmt go mod edit -fmt -print type Module struct { Path string Version string } type GoMod struct { Module ModPath Go string Require []Require Exclude []Module Replace []Replace Retract []Retract } type ModPath struct { Path string Deprecated string } type Require struct { Path string Version string Indirect bool } type Replace struct { Old Module New Module } type Retract struct { Low string High string Rationale string } type Tool struct { Path string } go list -m -json all go mod edit -json -exclude go mod graph go mod graph [-go=version] example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0 @version -go go mod init [module-path] go mod init go mod init example.com/m init GLOCKFILE Godeps/Godeps.json Gopkg.lock dependencies.tsv glide.lock vendor.conf vendor.yml vendor/manifest vendor/vendor.json go mod tidy [-e] [-v] [-x] [-diff] [-go=version] [-compat=version] -e -v tidy -diff // +build ignore testdata go mod vendor [-e] [-v] [-o] -o go mod verify .zip GONOSUMDB go mod why [-m] [-vendor] packages... # $ go mod why golang.org/x/text/language golang.org/x/text/encoding # golang.org/x/text/language rsc.io/quote rsc.io/sampler golang.org/x/text/language # golang.org/x/text/encoding (main module does not need package golang.org/x/text/encoding) -vendor go version [-m] [-v] [file ...] # Print Go version used to build go. $ go version # Print Go version used to build a specific executable. $ go version /go/bin/gopls # Print Go version and module versions used to build a specific executable. $ go version -m /go/bin/gopls # Print Go version and module versions used to build executables in a directory. $ go version -m /go/bin/ go version $ go version -m /go/bin/goimports /home/jrgopher/go/bin/goimports: go1.14.3 path golang.org/x/tools/cmd/goimports mod golang.org/x/tools v0.0.0-20200518203908-8018eb2c26ba h1:0Lcy64USfQQL6GAJma8BdHCgeofcchQj+Z7j0SXYAzU= dep golang.org/x/mod v0.2.0 h1:KU7oHjnv3XNWfa5COkzUifxZmxp1TyI7ImMXqFxLwvQ= dep golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4= runtime/debug.ReadBuildInfo mod (devel) dep go clean [-modcache] -modcache go clean GOFLAGS go env -w go get example.com/m@latest go mod download example.com/m@master go list -m -json example.com/m@e3702bed2 v1.2 =v1.5.6 > >= < <= v1.2.2  go-import example.com/gopher https://example.com/gopher?go-get=1  https://modproxy.example.com/example.com/gopher/@v/v1.0.0.info v1.0.0.mod v1.0.0.zip PATH .bzr .fossil .git .hg .svn example.com/foo.git/bar example.com/foo bar ?go-get=1 https://golang.org/x/mod?go-get=1 (preferred) http://golang.org/x/mod?go-get=1 (fallback, only with GOINSECURE)   root-path vcs repo-url https:// git+ssh:// http:// git:// bzr https bzr+ssh fossil git git+ssh ssh hg svn svn+ssh https://golang.org/x/mod?go-get=1  https://go.googlesource.com/mod v2.4.0-beta v3.0.0+incompatible v0.4.0 gopls/v0.4.0 v1.3.2-0.20191109021931-daa7c04131f5 daa7c04131f5 20191109021931 v1.3.1 v1.3.2 go get example.com/mod@master example.com/monorepo/foo/bar example.com/monorepo foo/bar example.com/monorepo/foo/bar/v2 foo/bar/v2 GOPATH/src //go:embed LICENSE .txt GOVCS pattern:vcslist GOVCS=github.com:git,evil.com:off,:git|hg github.com/ evil.com  public private public:git|hg,private:all GOVCS=:all GOVCS=:off golang.org/x/mod/zip $module@$version/ golang.org/x/mod@v0.3.0/ strings.EqualFold $module@$version/go.mod !#$%&()+,-.=@[]^{} module.CheckFilePath module.CheckImportPath .profile https://proxy.corp.example.com corp.example.com GOPROXY=https://proxy.corp.example.com GONOSUMDB=corp.example.com GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org,direct GONOSUMDB=corp.example.com https://proxy.golang.org GOPRIVATE=corp.example.com https://proxy.golang.org,direct corp.example.com/mod https://corp.example.com/mod?go-get=1 corp.example.com/repo.git/mod https://corp.example.com/repo.git ssh://corp.example.com/repo.git .gitconfig GITTERMINALPROMPT=0 .netrc proxy.corp.example.com machine proxy.corp.example.com login jrgopher password hunter2 NETRC $HOME/.netrc %USERPROFILE%\netrc GOPROXY=https://jrgopher:hunter2@proxy.corp.example.com ssh:// [url "git@github.com:"] insteadOf = https://github.com/ proxy.golang.org GOPRIVATE=.corp.example.com,.research.example.com GOPROXY=https://proxy.corp.example.com GONOSUMDB=.corp.example.com,.research.example.com GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org GONOSUMDB=.corp.example.com,.research.example.com go mod download corp.example.com/secret-product/typo@latest secret-product sum.golang.org $GOPATH/pkg/mod GOMODCACHE rm -rf Azure !azure cache/download/ cache/download/$module/@v/list cache/download/$module/@v/$version.info cache/download/$module/@v/$version.mod cache/download/$module/@v/$version.zip cache/download/$module/@v/$version.ziphash cache/download/sumdb/ cache/vcs/ golang.org/x/mod/sumdb/dirhash GOSUMDB=off /go.mod h1 : h2 https://sum.golang.org https://sum.golang.org/lookup/golang.org/x/text@v0.3.2 [.p/$W] $base/latest golang.org/x/mod/sumdb/tlog#FormatTree $base/lookup/$module@$version $base/tile/$H/$L/$K[.p/$W] $L $K $H .p/$W $W $base/tile/$H/data/$K[.p/$W] /tile/$H/0/$K[.p/$W] data /lookup GOSUMDB="sum.golang.org" GOSUMDB="sum.golang.org+" GOSUMDB="sum.golang.org+ https://sum.golang.org" sum.golang.google.cn go help environment path.Match pkg/mod http file foolinuxamd64.go // +build linux,amd64 v1.2.3+meta import GOPROXY=direct 1 3 v1.2.3-beta4 +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | Command | Behavior | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go buildgo docgo fixgo fmtgo generatego installgo listgo rungo testgo vet | Only packages in the standard library and packages specified as.gofiles on the command line can be loaded, imported, and | | | built. Packages from other modules cannot be built, since there is no | | | place to record module requirements and ensure deterministic builds. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go get | Packages and executables may be built and installed as usual. Note that | | | there is no main module whengo getis run without ago.modfile, soreplaceandexcludedirectives are not applied. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go list -m | Explicitversion queriesare required | | | for most arguments, except when the-versionsflag is used. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go mod download | Explicitversion queriesare required | | | for most arguments. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go mod edit | An explicit file argument is required. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ | go mod graphgo mod tidygo mod vendorgo mod verifygo mod why | These commands require ago.modfile and will report | | | an error if one is not present. | +---------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------+ +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | Path | Description | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | $base/$module/@v/list | Returns a list of known versions of the given module in plain text, one | | | per line. This list should not include pseudo-versions. | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | $base/$module/@v/$version.info | Returns JSON-formatted metadata about a specific version of a module. | | | The response must be a JSON object that corresponds to the Go data | | | structure below:type Info struct { | | | Version string // version string | | | Time time.Time // commit time | | | }TheVersionfield is required and must contain a valid,canonical version(seeVersions). The$versionin the | | | request path does not need to be the same version or even a valid | | | version; this endpoint may be used to find versions for branch names | | | or revision identifiers. However, if$versionis a | | | canonical version with a major version compatible with$module, theVersionfield in a successful | | | response must be the same.TheTimefield is optional. If present, it must be a | | | string in RFC 3339 format. It indicates the time when the version | | | was created.More fields may be added in the future, so other names are reserved. | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | $base/$module/@v/$version.mod | Returns thego.modfile for a specific version of a | | | module. If the module does not have ago.modfile at the | | | requested version, a file containing only amodulestatement with the requested module path must be returned. Otherwise, | | | the original, unmodifiedgo.modfile must be returned. | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | $base/$module/@v/$version.zip | Returns a zip file containing the contents of a specific version of | | | a module. SeeModule zip filesfor details | | | on how this zip file must be formatted. | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ | $base/$module/@latest | Returns JSON-formatted metadata about the latest known version of a | | | module in the same format as$base/$module/@v/$version.info. The latest version should | | | be the version of the module that thegocommand should use | | | if$base/$module/@v/listis empty or no listed version is | | | suitable. This endpoint is optional, and module proxies are not required | | | to implement it. | +--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+ +------------+---------+--------------------+-------------------+ | Name | Command | GOVCS default | Secure schemes | +------------+---------+--------------------+-------------------+ | Bazaar | bzr | Private only | https,bzr+ssh | +------------+---------+--------------------+-------------------+ | Fossil | fossil | Private only | https | +------------+---------+--------------------+-------------------+ | Git | git | Public and private | https,git+ssh,ssh | +------------+---------+--------------------+-------------------+ | Mercurial | hg | Public and private | https,ssh | +------------+---------+--------------------+-------------------+ | Subversion | svn | Private only | https,svn+ssh | +------------+---------+--------------------+-------------------+ +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | Path | Description | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | $module@$version/ | Directory containing extracted contents of a module.zipfile. This serves as a module root directory for a downloaded module. It | | | won't contain ago.modfile if the original module | | | didn't have one. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/ | Directory containing files downloaded from module proxies and files | | | derived fromversion control systems. The layout of | | | this directory follows theGOPROXYprotocol, so | | | this directory may be used as a proxy when served by an HTTP file | | | server or when referenced with afile://URL. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/$module/@v/list | List of known versions (seeGOPROXYprotocol). This | | | may change over time, so thegocommand usually fetches a | | | new copy instead of re-using this file. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/$module/@v/$version.info | JSON metadata about the version. (seeGOPROXYprotocol). This | | | may change over time, so thegocommand usually fetches a | | | new copy instead of re-using this file. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/$module/@v/$version.mod | Thego.modfile for this version (seeGOPROXYprotocol). If | | | the original module did not have ago.modfile, this is | | | a synthesized file with no requirements. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/$module/@v/$version.zip | The zipped contents of the module (seeGOPROXYprotocolandModule zip files). | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/$module/@v/$version.ziphash | A cryptographic hash of the files in the.zipfile. | | | Note that the.zipfile itself is not hashed, so file | | | order, compression, alignment, and metadata don't affect the hash. | | | When using a module, thegocommand verifies this hash | | | matches the corresponding line ingo.sum. Thego mod verifycommand checks | | | that the hashes of module.zipfiles and extracted | | | directories match these files. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/download/sumdb/ | Directory containing files downloaded from achecksum database(typicallysum.golang.org). | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ | cache/vcs/ | Contains cloned version control repositories for modules fetched | | | directly from their sources. Directory names are hex-encoded hashes | | | derived from the repository type and URL. Repositories are optimized | | | for size on disk. For example, cloned Git repositories are bare and | | | shallow when possible. | +--------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------+ +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | Path | Description | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/latest | Returns a signed, encoded tree description for the latest log. This | | | | | | | signed description is in the form of anote, | | | | | | | which is text that has been signed by one or more server keys and can | | | | | | | be verified using the server's public key. The tree description | | | | | | | provides the size of the tree and the hash of the tree head at that | | | | | | | size. This encoding is described ingolang.org/x/mod/sumdb/tlog#FormatTree. | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/lookup/$module@$version | Returns the log record number for the entry about$moduleat$version, followed by the data for the record (that is, | $base/tile/$H/$L/$K[.p/$W] | Returns a [log tile](https://research.swtch.com/tlog#servingtiles), | $base/tile/$H/data/$K[.p/$W] | Returns the record data for the leaf hashes in/tile/$H/0/$K[.p/$W](with a literaldatapath | | | thego.sumlines for$moduleat$version) and a signed, encoded tree description that | | which is a set of hashes that make up a section of the log. Each tile | | element). | | | contains the record. | | is defined in a two-dimensional coordinate at tile level$L,$Kth from the left, with a tile height of$H. The optional.p/$Wsuffix indicates a | | | | | | | partial log tile with only$Whashes. Clients must fall | | | | | | | back to fetching the full tile if a partial tile is not found. | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/lookup/$module@$version | Returns the log record number for the entry about$moduleat$version, followed by the data for the record (that is, | | | | | | | thego.sumlines for$moduleat$version) and a signed, encoded tree description that | | | | | | | contains the record. | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/tile/$H/$L/$K[.p/$W] | Returns a [log tile](https://research.swtch.com/tlog#servingtiles), | $base/tile/$H/data/$K[.p/$W] | Returns the record data for the leaf hashes in/tile/$H/0/$K[.p/$W](with a literaldatapath | | | | | which is a set of hashes that make up a section of the log. Each tile | | element). | | | | | is defined in a two-dimensional coordinate at tile level$L,$Kth from the left, with a tile height of$H. The optional.p/$Wsuffix indicates a | | | | | | | partial log tile with only$Whashes. Clients must fall | | | | | | | back to fetching the full tile if a partial tile is not found. | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/tile/$H/$L/$K[.p/$W] | Returns a [log tile](https://research.swtch.com/tlog#servingtiles), | | | | | | | which is a set of hashes that make up a section of the log. Each tile | | | | | | | is defined in a two-dimensional coordinate at tile level$L,$Kth from the left, with a tile height of$H. The optional.p/$Wsuffix indicates a | | | | | | | partial log tile with only$Whashes. Clients must fall | | | | | | | back to fetching the full tile if a partial tile is not found. | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/tile/$H/data/$K[.p/$W] | Returns the record data for the leaf hashes in/tile/$H/0/$K[.p/$W](with a literaldatapath | | | | | | | element). | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ | $base/tile/$H/data/$K[.p/$W] | Returns the record data for the leaf hashes in/tile/$H/0/$K[.p/$W](with a literaldatapath | | | | | | | element). | | | | | +-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------+-------------------------------------------------------------------------------------------+ +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Variable | Description | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GO111MODULE | Controls whether thegocommand runs in module-aware mode | | | orGOPATHmode. Three values are recognized:off: thegocommand ignoresgo.modfiles and runs inGOPATHmode.on(or unset): thegocommand runs in | | | module-aware mode, even when nogo.modfile is present.auto: thegocommand runs in module-aware | | | mode if ago.modfile is present in the current | | | directory or any parent directory. In Go 1.15 and lower, this was | | | the default.SeeModule-aware commandsfor more | | | information. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOMODCACHE | The directory where thegocommand will store downloaded | | | modules and related files. SeeModule | | | cachefor details on the structure of this directory.IfGOMODCACHEis not set, it defaults to$GOPATH/pkg/mod. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOINSECURE | Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path | | | prefixes that may always be fetched in an insecure manner. Only | | | applies to dependencies that are being fetched directly.Unlike the-insecureflag ongo get,GOINSECUREdoes not disable module checksum database | | | validation.GOPRIVATEorGONOSUMDBmay be | | | used to achieve that. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GONOPROXY | Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path | | | prefixes that should always be fetched directly from version control | | | repositories, not from module proxies.IfGONOPROXYis not set, it defaults toGOPRIVATE. SeePrivacy. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GONOSUMDB | Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path | | | prefixes for which thegoshould not verify checksums | | | using the checksum database.IfGONOSUMDBis not set, it defaults toGOPRIVATE. SeePrivacy. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOPATH | InGOPATHmode, theGOPATHvariable is a | | | list of directories that may contain Go code.In module-aware mode, themodule | | | cacheis stored in thepkg/modsubdirectory of the | | | firstGOPATHdirectory. Module source code outside the | | | cache may be stored in any directory.IfGOPATHis not set, it defaults to thegosubdirectory of the user's home directory. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOPRIVATE | Comma-separated list of glob patterns (in the syntax of Go'spath.Match) of module path | | | prefixes that should be considered private.GOPRIVATEis a default value forGONOPROXYandGONOSUMDB. SeePrivacy.GOPRIVATEalso determines whether a module is considered private forGOVCS. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOPROXY | List of module proxy URLs, separated by commas (,) or | | | pipes (|). When thegocommand looks up | | | information about a module, it contacts each proxy in the list in | | | sequence until it receives a successful response or a terminal error. | | | A proxy may respond with a 404 (Not Found) or 410 (Gone) status to | | | indicate the module is not available on that server.Thegocommand's error fallback behavior is determined | | | by the separator characters between URLs. If a proxy URL is followed | | | by a comma, thegocommand falls back to the next URL | | | after a 404 or 410 error; all other errors are considered terminal. | | | If the proxy URL is followed by a pipe, thegocommand | | | falls back to the next source after any error, including non-HTTP | | | errors like timeouts.GOPROXYURLs may have the schemeshttps,http, orfile. If a URL has no scheme,httpsis assumed. A module cache may be used directly as | | | a file proxy:GOPROXY=file://$(go env GOMODCACHE)/cache/downloadTwo keywords may be used in place of proxy URLs:off: disallows downloading modules from any source.direct: download directly from version control | | | repositories instead of using a module proxy.GOPROXYdefaults tohttps://proxy.golang.org,direct. Under that | | | configuration, thegocommand first contacts the Go | | | module mirror run by Google, then falls back to a direct connection if | | | the mirror does not have the module. Seehttps://proxy.golang.org/privacyfor the mirror's privacy policy. TheGOPRIVATEandGONOPROXYenvironment variables may be set to prevent | | | specific modules from being downloaded using proxies. SeePrivacyfor information on | | | private proxy configuration.SeeModule proxiesandResolving a package to a modulefor | | | more information on how proxies are used. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOSUMDB | Identifies the name of the checksum database to use and optionally | | | its public key and URL. For example:GOSUMDB="sum.golang.org" | | | GOSUMDB="sum.golang.org+" | | | GOSUMDB="sum.golang.org+ https://sum.golang.org"Thegocommand knows the public key ofsum.golang.organd also that the namesum.golang.google.cn(available inside mainland China) | | | connects to thesum.golang.orgdatabase; use of any other | | | database requires giving the public key explicitly. The URL defaults | | | tohttps://followed by the database name.GOSUMDBdefaults tosum.golang.org, the | | | Go checksum database run by Google. Seehttps://sum.golang.org/privacyfor the service's privacy policy.IfGOSUMDBis set tooffor ifgo getis invoked with the-insecureflag, | | | the checksum database is not consulted, and all unrecognized modules | | | are accepted, at the cost of giving up the security guarantee of | | | verified repeatable downloads for all modules. A better way to bypass | | | the checksum database for specific modules is to use theGOPRIVATEorGONOSUMDBenvironment | | | variables.SeeAuthenticating modulesandPrivacyfor more information. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOVCS | Controls the set of version control tools thegocommand | | | may use to download public and private modules (defined by whether | | | their paths match a pattern inGOPRIVATE) or other | | | modules matching a glob pattern.IfGOVCSis not set, or if a module does not match any | | | pattern inGOVCS, thegocommand may usegitandhgfor a public module, or any known | | | version control tool for a private module. Concretely, thegocommand acts as ifGOVCSwere set to:public:git|hg,private:allSeeControlling version control tools withGOVCSfor a complete explanation. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | GOWORK | The GOWORK environment variable instructs the go command to enter workspace | | | mode using the provided [go.work file](#go-work-file) to define the workspace. | | | If GOWORK is set to off workspace mode is disabled. This can be used to run | | | the go command in single module mode: for example, GOWORK=off go build . builds | | | the . package in single-module mode.If GOWORK is empty, the | | | go command will search for a go.work file as described in the [Workspaces](#workspaces) | | | section. | +-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected 💡 If an old package and a new package have the same import path, the new package must be backwards compatible with the old package.