The Go Blog The Go image package Introduction Colors and Color Models Points and Rectangles Images Image Formats Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Nigel Tao21 September 2011 Theimageandimage/colorpackages define a number of types:color.Colorandcolor.Modeldescribe colors,image.Pointandimage.Rectangledescribe basic 2-D geometry, andimage.Imagebrings the two concepts together to represent a rectangular grid of colors. Aseparate articlecovers image composition with theimage/drawpackage. Coloris an interface that defines the minimal method set of any type that can be considered a color: one that can be converted to red, green, blue and alpha values. The conversion may be lossy, such as converting from CMYK or YCbCr color spaces. There are three important subtleties about the return values. First, the red, green and blue are alpha-premultiplied: a fully saturated red that is also 25% transparent is represented by RGBA returning a 75% r. Second, the channels have a 16-bit effective range: 100% red is represented by RGBA returning an r of 65535, not 255, so that converting from CMYK or YCbCr is not as lossy. Third, the type returned isuint32, even though the maximum value is 65535, to guarantee that multiplying two values together won’t overflow. Such multiplications occur when blending two colors according to an alpha mask from a third color, in the style ofPorter and Duff’sclassic algebra: The last line of that code snippet would have been more complicated if we worked with non-alpha-premultiplied colors, which is whyColoruses alpha-premultiplied values. The image/color package also defines a number of concrete types that implement theColorinterface. For example,RGBAis a struct that represents the classic “8 bits per channel” color. Note that theRfield of anRGBAis an 8-bit alpha-premultiplied color in the range [0, 255].RGBAsatisfies theColorinterface by multiplying that value by 0x101 to generate a 16-bit alpha-premultiplied color in the range [0, 65535]. Similarly, theNRGBAstruct type represents an 8-bit non-alpha-premultiplied color, as used by the PNG image format. When manipulating anNRGBA’s fields directly, the values are non-alpha-premultiplied, but when calling theRGBAmethod, the return values are alpha-premultiplied. AModelis simply something that can convertColors to otherColors, possibly lossily. For example, theGrayModelcan convert anyColorto a desaturatedGray. APalettecan convert anyColorto one from a limited palette. APointis an (x, y) co-ordinate on the integer grid, with axes increasing right and down. It is neither a pixel nor a grid square. APointhas no intrinsic width, height or color, but the visualizations below use a small colored square. ARectangleis an axis-aligned rectangle on the integer grid, defined by its top-left and bottom-rightPoint. ARectanglealso has no intrinsic color, but the visualizations below outline rectangles with a thin colored line, and call out theirMinandMaxPoints. For convenience,image.Rect(x0, y0, x1, y1)is equivalent toimage.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}}, but is much easier to type. ARectangleis inclusive at the top-left and exclusive at the bottom-right. For aPoint pand aRectangle r,p.In(r)if and only ifr.Min.X <= p.X && p.X < r.Max.X, and similarly forY. This is analogous to how a slices[i0:i1]is inclusive at the low end and exclusive at the high end. (Unlike arrays and slices, aRectangleoften has a non-zero origin.) Adding aPointto aRectangletranslates theRectangle. Points and Rectangles are not restricted to be in the bottom-right quadrant. Intersecting two Rectangles yields another Rectangle, which may be empty. Points and Rectangles are passed and returned by value. A function that takes aRectangleargument will be as efficient as a function that takes twoPointarguments, or fourintarguments. AnImagemaps every grid square in aRectangleto aColorfrom aModel. “The pixel at (x, y)” refers to the color of the grid square defined by the points (x, y), (x+1, y), (x+1, y+1) and (x, y+1). A common mistake is assuming that anImage’s bounds start at (0, 0). For example, an animated GIF contains a sequence of Images, and eachImageafter the first typically only holds pixel data for the area that changed, and that area doesn’t necessarily start at (0, 0). The correct way to iterate over anImagem’s pixels looks like: Imageimplementations do not have to be based on an in-memory slice of pixel data. For example, aUniformis anImageof enormous bounds and uniform color, whose in-memory representation is simply that color. Typically, though, programs will want an image based on a slice. Struct types likeRGBAandGray(which other packages refer to asimage.RGBAandimage.Gray) hold slices of pixel data and implement theImageinterface. These types also provide aSet(x, y int, c color.Color)method that allows modifying the image one pixel at a time. If you’re reading or writing a lot of pixel data, it can be more efficient, but more complicated, to access these struct type’sPixfield directly. The slice-basedImageimplementations also provide aSubImagemethod, which returns anImagebacked by the same array. Modifying the pixels of a sub-image will affect the pixels of the original image, analogous to how modifying the contents of a sub-slices[i0:i1]will affect the contents of the original slices. For low-level code that works on an image’sPixfield, be aware that ranging overPixcan affect pixels outside an image’s bounds. In the example above, the pixels covered bym1.Pixare shaded in blue. Higher-level code, such as theAtandSetmethods or theimage/draw package, will clip their operations to the image’s bounds. The standard package library supports a number of common image formats, such as GIF, JPEG and PNG. If you know the format of a source image file, you can decode from anio.Readerdirectly. If you have image data of unknown format, theimage.Decodefunction can detect the format. The set of recognized formats is constructed at run time and is not limited to those in the standard package library. An image format package typically registers its format in an init function, and the main package will “underscore import” such a package solely for the side effect of format registration. Next article:The Go image/draw packagePrevious article:The Laws of ReflectionBlog Index Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Copyright Terms of Service Privacy Policy Report an Issue go type Color interface { // RGBA returns the alpha-premultiplied red, green, blue and alpha values // for the color. Each value ranges within [0, 0xFFFF], but is represented // by a uint32 so that multiplying by a blend factor up to 0xFFFF will not // overflow. RGBA() (r, g, b, a uint32) }  go dstr, dstg, dstb, dsta := dst.RGBA() srcr, srcg, srcb, srca := src.RGBA() , , , m := mask.RGBA() const M = 1<<16 - 1 // The resultant red value is a blend of dstr and srcr, and ranges in [0, M]. // The calculation for green, blue and alpha is similar. dstr = (dstr(M-m) + srcrm) / M  go type RGBA struct { R, G, B, A uint8 }  go type Model interface { Convert(c Color) Color } type Palette []Color  go type Point struct { X, Y int }  go p := image.Point{2, 1}  go type Rectangle struct { Min, Max Point }  go r := image.Rect(2, 1, 5, 5) // Dx and Dy return a rectangle's width and height. fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 false  go r := image.Rect(2, 1, 5, 5).Add(image.Pt(-4, -2)) fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 true  go r := image.Rect(0, 0, 4, 3).Intersect(image.Rect(2, 2, 5, 5)) // Size returns a rectangle's width and height, as a Point. fmt.Printf("%#v\n", r.Size()) // prints image.Point{X:2, Y:1}  go type Image interface { // ColorModel returns the Image's color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color }  go b := m.Bounds() for y := b.Min.Y; y < b.Max.Y; y++ { for x := b.Min.X; x < b.Max.X; x++ { doStuffWith(m.At(x, y)) } }  go type Uniform struct { C color.Color }  go type RGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)Stride + (x-Rect.Min.X)4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }  go m := image.NewRGBA(image.Rect(0, 0, 640, 480)) m.Set(5, 5, color.RGBA{255, 0, 0, 255})  go m0 := image.NewRGBA(image.Rect(0, 0, 8, 5)) m1 := m0.SubImage(image.Rect(1, 2, 5, 5)).(image.RGBA) fmt.Println(m0.Bounds().Dx(), m1.Bounds().Dx()) // prints 8, 4 fmt.Println(m0.Stride == m1.Stride) // prints true  go import ( "image/jpeg" "image/png" "io" ) // convertJPEGToPNG converts from JPEG to PNG. func convertJPEGToPNG(w io.Writer, r io.Reader) error { img, err := jpeg.Decode(r) if err != nil { return err } return png.Encode(w, img) }  go import ( "image" "image/png" "io"  "code.google.com/p/vp8-go/webp"  "image/jpeg" ) // convertToPNG converts from any recognized format to PNG. func convertToPNG(w io.Writer, r io.Reader) error { img, , err := image.Decode(r) if err != nil { return err } return png.Encode(w, img) }  color.Color color.Model image.Point image.Rectangle image.Image type Color interface { // RGBA returns the alpha-premultiplied red, green, blue and alpha values // for the color. Each value ranges within [0, 0xFFFF], but is represented // by a uint32 so that multiplying by a blend factor up to 0xFFFF will not // overflow. RGBA() (r, g, b, a uint32) } uint32 dstr, dstg, dstb, dsta := dst.RGBA() srcr, srcg, srcb, srca := src.RGBA() , , , m := mask.RGBA() const M = 1<<16 - 1 // The resultant red value is a blend of dstr and srcr, and ranges in [0, M]. // The calculation for green, blue and alpha is similar. dstr = (dstr(M-m) + srcrm) / M Color RGBA type RGBA struct { R, G, B, A uint8 } R NRGBA Model GrayModel Gray Palette type Model interface { Convert(c Color) Color } type Palette []Color Point type Point struct { X, Y int } p := image.Point{2, 1} Rectangle Min Max type Rectangle struct { Min, Max Point } image.Rect(x0, y0, x1, y1) image.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}} Point p Rectangle r p.In(r) r.Min.X <= p.X && p.X < r.Max.X Y s[i0:i1] r := image.Rect(2, 1, 5, 5) // Dx and Dy return a rectangle's width and height. fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 false r := image.Rect(2, 1, 5, 5).Add(image.Pt(-4, -2)) fmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 true r := image.Rect(0, 0, 4, 3).Intersect(image.Rect(2, 2, 5, 5)) // Size returns a rectangle's width and height, as a Point. fmt.Printf("%#v\n", r.Size()) // prints image.Point{X:2, Y:1} int type Image interface { // ColorModel returns the Image's color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color } Image b := m.Bounds() for y := b.Min.Y; y < b.Max.Y; y++ { for x := b.Min.X; x < b.Max.X; x++ { doStuffWith(m.At(x, y)) } } Uniform type Uniform struct { C color.Color } image.RGBA image.Gray type RGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)Stride + (x-Rect.Min.X)4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle } Set(x, y int, c color.Color) m := image.NewRGBA(image.Rect(0, 0, 640, 480)) m.Set(5, 5, color.RGBA{255, 0, 0, 255}) Pix SubImage s m0 := image.NewRGBA(image.Rect(0, 0, 8, 5)) m1 := m0.SubImage(image.Rect(1, 2, 5, 5)).(image.RGBA) fmt.Println(m0.Bounds().Dx(), m1.Bounds().Dx()) // prints 8, 4 fmt.Println(m0.Stride == m1.Stride) // prints true m1.Pix At Set io.Reader import ( "image/jpeg" "image/png" "io" ) // convertJPEGToPNG converts from JPEG to PNG. func convertJPEGToPNG(w io.Writer, r io.Reader) error { img, err := jpeg.Decode(r) if err != nil { return err } return png.Encode(w, img) } image.Decode import ( "image" "image/png" "io"  "code.google.com/p/vp8-go/webp"  "image/jpeg" ) // convertToPNG converts from any recognized format to PNG. func convertToPNG(w io.Writer, r io.Reader) error { img, , err := image.Decode(r) if err != nil { return err } return png.Encode(w, img) } 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected