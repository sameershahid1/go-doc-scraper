Opening a database handle Locating and importing a database driver Opening a database handle Confirming a connection Storing database credentials Freeing resources Opening with a connection string Opening with a Connector Handling errors Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Thedatabase/sqlpackage simplifies database access by reducing the need for you to manage connections. Unlike many data access APIs, withdatabase/sqlyou don’t explicitly open a connection, do work, then close the connection. Instead, your code opens a database handle that represents a connection pool, then executes data access operations with the handle, calling aClosemethod only when needed to free resources, such as those held by retrieved rows or a prepared statement. In other words, it’s the database handle, represented by ansql.DB, that handles connections, opening and closing them on your code’s behalf. As your code uses the handle to execute database operations, those operations have concurrent access to the database. For more, seeManaging connections. Note:You can also reserve a database connection. For more information, seeUsing dedicated connections. In addition to the APIs available in thedatabase/sqlpackage, the Go community has developed drivers for all of the most common (and many uncommon) database management systems (DBMSes). When opening a database handle, you follow these high-level steps: Locate a driver. A driver translates requests and responses between your Go code and the database. For more, seeLocating and importing a database driver. Open a database handle. After you’ve imported the driver, you can open a handle for a specific database. For more, seeOpening a database handle. Confirm a connection. Once you’ve opened a database handle, your code can check that a connection is available. For more, seeConfirming a connection. Your code typically won’t explicitly open or close database connections – that’s done by the database handle. However, your code should free resources it obtains along the way, such as ansql.Rowscontaining query results. For more, seeFreeing resources. You’ll need a database driver that supports the DBMS you’re using. To locate a driver for your database, seeSQLDrivers. To make the driver available to your code, you import it as you would another Go package. Here’s an example: Note that if you’re not calling any functions directly from the driver package –- such as when it’s being used implicitly by thesqlpackage – you’ll need to use a blank import, which prefixes the import path with an underscore: Note:As a best practice, avoid using the database driver’s own API for database operations. Instead, use functions in thedatabase/sqlpackage. This will help keep your code loosely coupled with the DBMS, making it easier to switch to a different DBMS if you need to. Ansql.DBdatabase handle provides the ability to read from and write to a database, either individually or in a transaction. You can get a database handle by calling eithersql.Open(which takes a connection string) orsql.OpenDB(which takes adriver.Connector). Both return a pointer to ansql.DB. Note:Be sure to keep your database credentials out of your Go source. For more, seeStoring database credentials. Use thesql.Openfunctionwhen you want to connect using a connection string. The format for the string will vary depending on the driver you’re using. Here’s an example for MySQL: However, you’ll likely find that capturing connection properties in a more structured way gives you code that’s more readable. The details will vary by driver. For example, you could replace the preceding example with the following, which uses the MySQL driver’sConfigto specify properties and itsFormatDSN methodto build a connection string. Use thesql.OpenDB functionwhen you want to take advantage of driver-specific connection features that aren’t available in a connection string. Each driver supports its own set of connection properties, often providing ways to customize the connection request specific to the DBMS. Adapting the precedingsql.Openexample to usesql.OpenDB, you could create a handle with code such as the following: Your code should check for an error from attempting to create a handle, such as withsql.Open. This won’t be a connection error. Instead, you’ll get an error ifsql.Openwas unable to initialize the handle. This could happen, for example, if it’s unable to parse the DSN you specified. When you open a database handle, thesqlpackage may not create a new database connection itself right away. Instead, it may create the connection when your code needs it. If you won’t be using the database right away and want to confirm that a connection could be established, callPingorPingContext. Code in the following example pings the database to confirm a connection. Avoid storing database credentials in your Go source, which could expose the contents of your database to others. Instead, find a way to store them in a location outside your code but available to it. For example, consider a secret keeper app that stores credentials and provides an API your code can use to retrieve credentials for authenticating with your DBMS. One popular approach is to store the secrets in the environment before the program starts, perhaps loaded from a secret manager, and then your Go program can read them usingos.Getenv: This approach also lets you set the environment variables yourself for local testing. Although you don’t manage or close connections explicitly with thedatabase/sqlpackage, your code should free resources it has obtained when they’re no longer needed. Those can include resources held by ansql.Rowsrepresenting data returned from a query or ansql.Stmtrepresenting a prepared statement. Typically, you close resources by deferring a call to aClosefunction so that resources are released before the enclosing function exits. Code in the following example defersCloseto free the resource held bysql.Rows. Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Documentation Accessing relational databases Opening a database handle Locate a driver.A driver translates requests and responses between your Go code and the database. For more, seeLocating and importing a database driver. Open a database handle.After you’ve imported the driver, you can open a handle for a specific database. For more, seeOpening a database handle. Confirm a connection.Once you’ve opened a database handle, your code can check that a connection is available. For more, seeConfirming a connection. Copyright Terms of Service Privacy Policy Report an Issue go import "github.com/go-sql-driver/mysql"  go import  "github.com/go-sql-driver/mysql"  go db, err = sql.Open("mysql", "username:password@tcp(127.0.0.1:3306)/jazzrecords") if err != nil { log.Fatal(err) }  go // Specify connection properties. cfg := mysql.Config{ User: username, Passwd: password, Net: "tcp", Addr: "127.0.0.1:3306", DBName: "jazzrecords", } // Get a database handle. db, err = sql.Open("mysql", cfg.FormatDSN()) if err != nil { log.Fatal(err) }  go // Specify connection properties. cfg := mysql.Config{ User: username, Passwd: password, Net: "tcp", Addr: "127.0.0.1:3306", DBName: "jazzrecords", } // Get a driver-specific connector. connector, err := mysql.NewConnector(&cfg) if err != nil { log.Fatal(err) } // Get a database handle. db = sql.OpenDB(connector)  go db, err = sql.Open("mysql", connString) // Confirm a successful connection. if err := db.Ping(); err != nil { log.Fatal(err) }  go username := os.Getenv("DBUSER") password := os.Getenv("DBPASS")  go rows, err := db.Query("SELECT  FROM album WHERE artist = ?", artist) if err != nil { log.Fatal(err) } defer rows.Close() // Loop through returned rows.  database/sql Close sql.DB sql.Rows import "github.com/go-sql-driver/mysql" sql import  "github.com/go-sql-driver/mysql" sql.Open sql.OpenDB driver.Connector db, err = sql.Open("mysql", "username:password@tcp(127.0.0.1:3306)/jazzrecords") if err != nil { log.Fatal(err) } Config FormatDSN method // Specify connection properties. cfg := mysql.Config{ User: username, Passwd: password, Net: "tcp", Addr: "127.0.0.1:3306", DBName: "jazzrecords", } // Get a database handle. db, err = sql.Open("mysql", cfg.FormatDSN()) if err != nil { log.Fatal(err) } sql.OpenDB function // Specify connection properties. cfg := mysql.Config{ User: username, Passwd: password, Net: "tcp", Addr: "127.0.0.1:3306", DBName: "jazzrecords", } // Get a driver-specific connector. connector, err := mysql.NewConnector(&cfg) if err != nil { log.Fatal(err) } // Get a database handle. db = sql.OpenDB(connector) Ping PingContext db, err = sql.Open("mysql", connString) // Confirm a successful connection. if err := db.Ping(); err != nil { log.Fatal(err) } os.Getenv username := os.Getenv("DBUSER") password := os.Getenv("DBPASS") sql.Stmt rows, err := db.Query("SELECT  FROM album WHERE artist = ?", artist) if err != nil { log.Fatal(err) } defer rows.Close() // Loop through returned rows. 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected