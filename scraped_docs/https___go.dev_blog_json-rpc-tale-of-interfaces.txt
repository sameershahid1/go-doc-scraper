The Go Blog JSON-RPC: a tale of interfaces Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Andrew Gerrand27 April 2010 Here we present an example where Goâ€™sinterfacesmade it easy to refactor some existing code to make it more flexible and extensible. Originally, the standard libraryâ€™sRPC packageused a custom wire format calledgob. For a particular application, we wanted to useJSONas an alternate wire format. We first defined a pair of interfaces to describe the functionality of the existing wire format, one for the client, and one for the server (depicted below). On the server side, we then changed two internal function signatures to accept theServerCodecinterface instead of our existinggob.Encoder. Hereâ€™s one of them: became We then wrote a trivialgobServerCodecwrapper to reproduce the original functionality. From there it is simple to build ajsonServerCodec. After some similar changes to the client side, this was the full extent of the work we needed to do on the RPC package. This whole exercise took about 20 minutes! After tidying up and testing the new code, thefinal changesetwas submitted. In an inheritance-oriented language like Java or C++, the obvious path would be to generalize the RPC class, and create JsonRPC and GobRPC subclasses. However, this approach becomes tricky if you want to make a further generalization orthogonal to that hierarchy. (For example, if you were to implement an alternate RPC standard). In our Go package, we took a route that is both conceptually simpler and requires less code be written or changed. A vital quality for any codebase is maintainability. As needs change, it is essential to adapt your code easily and cleanly, lest it become unwieldy to work with. We believe Goâ€™s lightweight, composition-oriented type system provides a means of structuring code that scales. Next article:New Talk and TutorialsPrevious article:Third-party libraries: goprotobuf and beyondBlog Index Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Copyright Terms of Service Privacy Policy Report an Issue go type ServerCodec interface { ReadRequestHeader(Request) error ReadRequestBody(interface{}) error WriteResponse(Response, interface{}) error Close() error }  go func sendResponse(sending sync.Mutex, req Request, reply interface{}, enc gob.Encoder, errmsg string)  go func sendResponse(sending sync.Mutex, req Request, reply interface{}, enc ServerCodec, errmsg string)  type ServerCodec interface { ReadRequestHeader(Request) error ReadRequestBody(interface{}) error WriteResponse(Response, interface{}) error Close() error } ServerCodec gob.Encoder func sendResponse(sending sync.Mutex, req Request, reply interface{}, enc gob.Encoder, errmsg string) func sendResponse(sending sync.Mutex, req Request, reply interface{}, enc ServerCodec, errmsg string) gobServerCodec jsonServerCodec ðŸ’¡ Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected