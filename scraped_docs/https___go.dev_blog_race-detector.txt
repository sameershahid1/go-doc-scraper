The Go Blog Introducing the Go Race Detector Introduction How it works Using the race detector Examples Conclusions Example 1: Timer.Reset Example 2: ioutil.Discard Common problems companies solve with Go Stories about how and why companies use Go How Go can help keep you secure by default Tips for writing clear, performant, and idiomatic Go code A complete introduction to building software with Go Reference documentation for Go's standard library Learn what's new in each Go release Videos from prior events Meet other local Go developers Learn and network with Go developers from around the world The Go project's official blog. Get help and stay informed from Go Dmitry Vyukov and Andrew Gerrand26 June 2013 Race conditionsare among the most insidious and elusive programming errors. They typically cause erratic and mysterious failures, often long after the code has been deployed to production. While Go’s concurrency mechanisms make it easy to write clean concurrent code, they don’t prevent race conditions. Care, diligence, and testing are required. And tools can help. We’re happy to announce that Go 1.1 includes arace detector, a new tool for finding race conditions in Go code. It is currently available for Linux, OS X, and Windows systems with 64-bit x86 processors. The race detector is based on the C/C++ThreadSanitizer runtime library, which has been used to detect many errors in Google’s internal code base and inChromium. The technology was integrated with Go in September 2012; since then it has detected42 racesin the standard library. It is now part of our continuous build process, where it continues to catch race conditions as they arise. The race detector is integrated with the go tool chain. When the-racecommand-line flag is set, the compiler instruments all memory accesses with code that records when and how the memory was accessed, while the runtime library watches for unsynchronized accesses to shared variables. When such “racy” behavior is detected, a warning is printed. (Seethis articlefor the details of the algorithm.) Because of its design, the race detector can detect race conditions only when they are actually triggered by running code, which means it’s important to run race-enabled binaries under realistic workloads. However, race-enabled binaries can use ten times the CPU and memory, so it is impractical to enable the race detector all the time. One way out of this dilemma is to run some tests with the race detector enabled. Load tests and integration tests are good candidates, since they tend to exercise concurrent parts of the code. Another approach using production workloads is to deploy a single race-enabled instance within a pool of running servers. The race detector is fully integrated with the Go tool chain. To build your code with the race detector enabled, just add the-raceflag to the command line: To try out the race detector for yourself, copy this example program intoracy.go: Then run it with the race detector enabled: Here are two examples of real issues caught by the race detector. The first example is a simplified version of an actual bug found by the race detector. It uses a timer to print a message after a random duration between 0 and 1 second. It does so repeatedly for five seconds. It usestime.AfterFuncto create aTimerfor the first message and then uses theResetmethod to schedule the next message, re-using theTimereach time. This looks like reasonable code, but under certain circumstances it fails in a surprising way: What’s going on here? Running the program with the race detector enabled is more illuminating: The race detector shows the problem: an unsynchronized read and write of the variabletfrom different goroutines. If the initial timer duration is very small, the timer function may fire before the main goroutine has assigned a value totand so the call tot.Resetis made with a nilt. To fix the race condition we change the code to read and write the variabletonly from the main goroutine: Here the main goroutine is wholly responsible for setting and resetting theTimertand a new reset channel communicates the need to reset the timer in a thread-safe way. A simpler but less efficient approach is toavoid reusing timers. The second example is more subtle. Theioutilpackage’sDiscardobject implementsio.Writer, but discards all the data written to it. Think of it like/dev/null: a place to send data that you need to read but don’t want to store. It is commonly used withio.Copyto drain a reader, like this: Back in July 2011 the Go team noticed that usingDiscardin this way was inefficient: theCopyfunction allocates an internal 32 kB buffer each time it is called, but when used withDiscardthe buffer is unnecessary since we’re just throwing the read data away. We thought that this idiomatic use ofCopyandDiscardshould not be so costly. The fix was simple. If the givenWriterimplements aReadFrommethod, aCopycall like this: is delegated to this potentially more efficient call: Weadded a ReadFrom methodto Discard’s underlying type, which has an internal buffer that is shared between all its users. We knew this was theoretically a race condition, but since all writes to the buffer should be thrown away we didn’t think it was important. When the race detector was implemented it immediatelyflagged this codeas racy. Again, we considered that the code might be problematic, but decided that the race condition wasn’t “real”. To avoid the “false positive” in our build we implementeda non-racy versionthat is enabled only when the race detector is running. But a few months laterBradencountered afrustrating and strange bug. After a few days of debugging, he narrowed it down to a real race condition caused byioutil.Discard. Here is the known-racy code inio/ioutil, whereDiscardis adevNullthat shares a single buffer between all of its users. Brad’s program includes atrackDigestReadertype, which wraps anio.Readerand records the hash digest of what it reads. For example, it could be used to compute the SHA-1 hash of a file while reading it: In some cases there would be nowhere to write the data—but still a need to hash the file—and soDiscardwould be used: But in this case theblackHolebuffer isn’t just a black hole; it is a legitimate place to store the data between reading it from the sourceio.Readerand writing it to thehash.Hash. With multiple goroutines hashing files simultaneously, each sharing the sameblackHolebuffer, the race condition manifested itself by corrupting the data between reading and hashing. No errors or panics occurred, but the hashes were wrong. Nasty! The bug was finallyfixedby giving a unique buffer to each use ofioutil.Discard, eliminating the race condition on the shared buffer. The race detector is a powerful tool for checking the correctness of concurrent programs. It will not issue false positives, so take its warnings seriously. But it is only as good as your tests; you must make sure they thoroughly exercise the concurrent properties of your code so that the race detector can do its job. What are you waiting for? Run"go test -race"on your code today! Next article:The first Go programPrevious article:Go and the Google Cloud PlatformBlog Index Why GoarrowdropdownPress Enter to activate/deactivate dropdownCase StudiesCommon problems companies solve with GoUse CasesStories about how and why companies use GoSecurityHow Go can help keep you secure by default Case StudiesCommon problems companies solve with Go Use CasesStories about how and why companies use Go SecurityHow Go can help keep you secure by default LearnPress Enter to activate/deactivate dropdown DocsarrowdropdownPress Enter to activate/deactivate dropdownEffective GoTips for writing clear, performant, and idiomatic Go codeGo User ManualA complete introduction to building software with GoStandard libraryReference documentation for Go's standard libraryRelease NotesLearn what's new in each Go release Effective GoTips for writing clear, performant, and idiomatic Go code Go User ManualA complete introduction to building software with Go Standard libraryReference documentation for Go's standard library Release NotesLearn what's new in each Go release PackagesPress Enter to activate/deactivate dropdown CommunityarrowdropdownPress Enter to activate/deactivate dropdownRecorded TalksVideos from prior eventsMeetupsopeninnewMeet other local Go developersConferencesopeninnewLearn and network with Go developers from around the worldGo blogThe Go project's official blog.Go projectGet help and stay informed from GoGet connected Recorded TalksVideos from prior events MeetupsopeninnewMeet other local Go developers ConferencesopeninnewLearn and network with Go developers from around the world Go blogThe Go project's official blog. Go projectGet help and stay informed from Go Get connected Why GonavigatenextnavigatebeforeWhy GoCase StudiesUse CasesSecurity Case Studies Use Cases Security Learn DocsnavigatenextnavigatebeforeDocsEffective GoGo User ManualStandard libraryRelease Notes Effective Go Go User Manual Standard library Release Notes Packages CommunitynavigatenextnavigatebeforeCommunityRecorded TalksMeetupsopeninnewConferencesopeninnewGo blogGo projectGet connected Recorded Talks Meetupsopeninnew Conferencesopeninnew Go blog Go project Get connected Copyright Terms of Service Privacy Policy Report an Issue go $ go test -race mypkg // test the package $ go run -race mysrc.go // compile and run the program $ go build -race mycmd // build the command $ go install -race mypkg // install the package  go package main import "fmt" func main() { done := make(chan bool) m := make(map[string]string) m["name"] = "world" go func() { m["name"] = "data race" done <- true }() fmt.Println("Hello,", m["name"]) <-done }  go $ go run -race racy.go  go package main import ( "fmt" "math/rand" "time" )  go 10 func main() { 11 start := time.Now() 12 var t time.Timer 13 t = time.AfterFunc(randomDuration(), func() { 14 fmt.Println(time.Now().Sub(start)) 15 t.Reset(randomDuration()) 16 }) 17 time.Sleep(5  time.Second) 18 } 19 20 func randomDuration() time.Duration { 21 return time.Duration(rand.Int63n(1e9)) 22 } 23  go panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x8 pc=0x41e38a] goroutine 4 [running]: time.stopTimer(0x8, 0x12fe6b35d9472d96) src/pkg/runtime/ztimelinuxamd64.c:35 +0x25 time.(Timer).Reset(0x0, 0x4e5904f, 0x1) src/pkg/time/sleep.go:81 +0x42 main.func·001() race.go:14 +0xe3 created by time.goFunc src/pkg/time/sleep.go:122 +0x48  go ================== WARNING: DATA RACE Read by goroutine 5: main.func·001() race.go:16 +0x169 Previous write by goroutine 1: main.main() race.go:14 +0x174 Goroutine 5 (running) created at: time.goFunc() src/pkg/time/sleep.go:122 +0x56 timerproc() src/pkg/runtime/ztimelinuxamd64.c:181 +0x189 ==================  go package main import ( "fmt" "math/rand" "time" )  go 10 func main() { 11 start := time.Now() 12 reset := make(chan bool) 13 var t time.Timer 14 t = time.AfterFunc(randomDuration(), func() { 15 fmt.Println(time.Now().Sub(start)) 16 reset <- true 17 }) 18 for time.Since(start) < 5time.Second { 19 <-reset 20 t.Reset(randomDuration()) 21 } 22 } 23  go func randomDuration() time.Duration { return time.Duration(rand.Int63n(1e9)) }  go io.Copy(ioutil.Discard, reader)  go io.Copy(writer, reader)  go writer.ReadFrom(reader)  go var blackHole [4096]byte // shared buffer func (devNull) ReadFrom(r io.Reader) (n int64, err error) { readSize := 0 for { readSize, err = r.Read(blackHole[:]) n += int64(readSize) if err != nil { if err == io.EOF { return n, nil } return } } }  go type trackDigestReader struct { r io.Reader h hash.Hash } func (t trackDigestReader) Read(p []byte) (n int, err error) { n, err = t.r.Read(p) t.h.Write(p[:n]) return }  go tdr := trackDigestReader{r: file, h: sha1.New()} io.Copy(writer, tdr) fmt.Printf("File hash: %x", tdr.h.Sum(nil))  go io.Copy(ioutil.Discard, tdr)  go func (t trackDigestReader) Read(p []byte) (n int, err error) { // the buffer p is blackHole n, err = t.r.Read(p) // p may be corrupted by another goroutine here, // between the Read above and the Write below t.h.Write(p[:n]) return }  -race $ go test -race mypkg // test the package $ go run -race mysrc.go // compile and run the program $ go build -race mycmd // build the command $ go install -race mypkg // install the package racy.go package main import "fmt" func main() { done := make(chan bool) m := make(map[string]string) m["name"] = "world" go func() { m["name"] = "data race" done <- true }() fmt.Println("Hello,", m["name"]) <-done } $ go run -race racy.go time.AfterFunc Timer Reset panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x8 pc=0x41e38a] goroutine 4 [running]: time.stopTimer(0x8, 0x12fe6b35d9472d96) src/pkg/runtime/ztimelinuxamd64.c:35 +0x25 time.(Timer).Reset(0x0, 0x4e5904f, 0x1) src/pkg/time/sleep.go:81 +0x42 main.func·001() race.go:14 +0xe3 created by time.goFunc src/pkg/time/sleep.go:122 +0x48 ================== WARNING: DATA RACE Read by goroutine 5: main.func·001() race.go:16 +0x169 Previous write by goroutine 1: main.main() race.go:14 +0x174 Goroutine 5 (running) created at: time.goFunc() src/pkg/time/sleep.go:122 +0x56 timerproc() src/pkg/runtime/ztimelinuxamd64.c:181 +0x189 ================== t t.Reset ioutil Discard io.Writer /dev/null io.Copy io.Copy(ioutil.Discard, reader) Copy Writer ReadFrom io.Copy(writer, reader) writer.ReadFrom(reader) ioutil.Discard io/ioutil devNull trackDigestReader io.Reader type trackDigestReader struct { r io.Reader h hash.Hash } func (t trackDigestReader) Read(p []byte) (n int, err error) { n, err = t.r.Read(p) t.h.Write(p[:n]) return } tdr := trackDigestReader{r: file, h: sha1.New()} io.Copy(writer, tdr) fmt.Printf("File hash: %x", tdr.h.Sum(nil)) io.Copy(ioutil.Discard, tdr) blackHole hash.Hash func (t trackDigestReader) Read(p []byte) (n int, err error) { // the buffer p is blackHole n, err = t.r.Read(p) // p may be corrupted by another goroutine here, // between the Read above and the Write below t.h.Write(p[:n]) return } "go test -race" 💡 Why Go navigatenext navigatebeforeWhy Go Case Studies Use Cases Security Learn Docs navigatenext navigatebeforeDocs Effective Go Go User Manual Standard library Release Notes Packages Community navigatenext navigatebeforeCommunity Recorded Talks Meetups openinnew Conferences openinnew Go blog Go project Get connected